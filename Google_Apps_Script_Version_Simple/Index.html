<!DOCTYPE html>
<html lang="es-CL">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador de Turnos üêü ‚Äî Planificador Industrial</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- xlsx-js-style: versi√≥n con soporte de estilos y colores -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
  <style>
    :root { --glass-bg: rgba(255, 255, 255, .58); --glass-stroke: rgba(255, 255, 255, .35); }
    html, body { height: 100%; overflow-x: hidden; width: 100%; max-width: 100vw; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 600px at 20% 0%, #c9d6ff 0%, transparent 60%),
                  radial-gradient(1000px 500px at 90% 10%, #e2d1f9 0%, transparent 55%),
                  linear-gradient(135deg, #eef2ff 0%, #e0e7ff 20%, #fdf2f8 100%);
      -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
      color: #0f172a;
    }
    .dark body {
      background: radial-gradient(1200px 600px at 20% 0%, #0b1220 0%, transparent 60%),
                  radial-gradient(1000px 500px at 90% 10%, #171a29 0%, transparent 55%),
                  linear-gradient(135deg, #0b1220 0%, #0f172a 30%, #111827 100%);
      color: #e5e7eb;
    }
    .dark :root { --glass-bg: rgba(17, 24, 39, .65); --glass-stroke: rgba(255,255,255,.08); }
    .glass { background: var(--glass-bg); backdrop-filter: blur(14px) saturate(120%); -webkit-backdrop-filter: blur(14px) saturate(120%); border: 1px solid var(--glass-stroke); box-shadow: 0 10px 30px rgba(2, 8, 23, .08), inset 0 1px 0 rgba(255,255,255,.25); }
    .sticky-left { position: sticky; left: 0; z-index: 10; }
    .chip { border-radius: 9999px; padding: .25rem .6rem; font-weight: 700; font-size: .75rem; }
    .cell-mini { font-size: .7rem; line-height: 1.1rem; }
    .print\:show { display: none; }
    @media print {
      .no-print { display: none !important; }
      header, .config-area, .groups-palette, .zones-area, .tabs-area { display: none !important; }
      #printArea { display: block !important; }
      body { background: white; color: #111827; }
      table { page-break-inside: avoid; }
    }
    /* Turno palettes */
    .shift-day{background-color:#fef3c7;border-left:3px solid #f59e0b;color:#92400e}
    .shift-afternoon{background-color:#fed7aa;border-left:3px solid #ea580c;color:#9a3412}
    .shift-night{background-color:#c7d2fe;border-left:3px solid #4f46e5;color:#3730a3}
    .shift-rest{background-color:#d1fae5;border-left:3px solid #10b981;color:#065f46}
    .badge { position:absolute; top:2px; right:2px; font-size:.6rem; background:#fbbf24; color:#78350f; padding:2px 4px; border-radius:4px; }
    .kbd { border:1px solid #cbd5e1; background:#f8fafc; border-bottom-width:2px; padding:2px 6px; border-radius:6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:.75rem }
    
    /* Contenedor de calendario con scroll controlado */
    .calendar-container {
      width: 100%;
      overflow-x: auto;
      overflow-y: visible;
      border-radius: 12px;
      border: 2px solid rgba(203, 213, 225, 0.5);
      background: white;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      margin-bottom: 1rem;
    }
    
    .calendar-container::-webkit-scrollbar { height: 12px; }
    .calendar-container::-webkit-scrollbar-track { background: #f1f5f9; border-radius: 6px; }
    .calendar-container::-webkit-scrollbar-thumb { background: #94a3b8; border-radius: 6px; }
    .calendar-container::-webkit-scrollbar-thumb:hover { background: #64748b; }
    
    .scroll-hint {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      padding: 10px 16px;
      background: linear-gradient(90deg, #dbeafe 0%, #e0e7ff 100%);
      border-radius: 8px;
      font-size: 0.875rem;
      color: #475569;
      margin-bottom: 12px;
      border-left: 4px solid #3b82f6;
    }
    
    .sticky-left {
      background: white !important;
      box-shadow: 2px 0 4px rgba(0, 0, 0, 0.1);
    }

    /* Drag & Drop feedback */
    .dragging {
      opacity: 0.5;
      transform: scale(0.95);
      cursor: grabbing !important;
    }
    .drag-over {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(168, 85, 247, 0.1) 100%) !important;
      border: 2px dashed #6366f1 !important;
      transform: scale(1.02);
      transition: all 0.2s ease;
    }
    .draggable-item {
      cursor: grab;
      transition: all 0.2s ease;
    }
    .draggable-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    /* Loading spinner */
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(99, 102, 241, 0.3);
      border-radius: 50%;
      border-top-color: #6366f1;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Toast mejorado */
    .toast {
      position: fixed;
      z-index: 9999;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      padding: 12px 24px;
      border-radius: 12px;
      font-weight: 600;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
      animation: slideUp 0.3s ease;
    }
    .toast-success {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
    }
    .toast-error {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      color: white;
    }
    .toast-info {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
    }
    @keyframes slideUp {
      from { transform: translateX(-50%) translateY(20px); opacity: 0; }
      to { transform: translateX(-50%) translateY(0); opacity: 1; }
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 9998;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.2s ease;
    }
    .modal-content {
      background: white;
      border-radius: 16px;
      padding: 24px;
      max-width: 90vw;
      max-height: 90vh;
      overflow: auto;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      animation: scaleIn 0.2s ease;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes scaleIn {
      from { transform: scale(0.9); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    /* Navigation buttons */
    .nav-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 16px;
      border-radius: 10px;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    .nav-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .nav-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Breadcrumb */
    .breadcrumb {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 100%);
      border-radius: 10px;
      font-size: 0.875rem;
      font-weight: 600;
      color: #374151;
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      .mobile-menu {
        position: fixed;
        top: 0;
        left: 0;
        width: 80%;
        max-width: 320px;
        height: 100vh;
        background: white;
        box-shadow: 4px 0 12px rgba(0, 0, 0, 0.1);
        transform: translateX(-100%);
        transition: transform 0.3s ease;
        z-index: 9999;
        overflow-y: auto;
      }
      .mobile-menu.open {
        transform: translateX(0);
      }
      .nav-btn, .tab-btn {
        min-height: 44px;
        min-width: 44px;
      }
    }

    /* Tooltip mejorado */
    .tooltip {
      position: relative;
    }
    .tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(-8px);
      padding: 8px 12px;
      background: rgba(15, 23, 42, 0.95);
      color: white;
      font-size: 0.75rem;
      border-radius: 8px;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 1000;
    }
    .tooltip:hover::after {
      opacity: 1;
    }

    /* Screen reader only */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border-width: 0;
    }

    /* Focus visible mejorado para accesibilidad */
    *:focus-visible {
      outline: 2px solid #6366f1;
      outline-offset: 2px;
      border-radius: 4px;
    }

    /* Construcci√≥n manual de turnos */
    .manual-shift-chip {
      cursor: grab;
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 0.875rem;
      user-select: none;
    }
    .manual-shift-chip:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    .manual-shift-chip.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .manual-calendar {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      margin-top: 12px;
    }

    .manual-day-cell {
      min-height: 80px;
      border: 2px solid #e2e8f0;
      border-radius: 8px;
      padding: 6px;
      background: white;
      transition: all 0.2s ease;
      position: relative;
    }

    .manual-day-cell:hover {
      border-color: #cbd5e1;
      background: #f8fafc;
    }

    .manual-day-cell.drag-over-manual {
      border-color: #6366f1;
      background: rgba(99, 102, 241, 0.05);
      border-style: dashed;
    }

    .manual-day-cell.disabled {
      background: #f1f5f9;
      opacity: 0.5;
      pointer-events: none;
    }

    .manual-day-header {
      font-size: 0.75rem;
      font-weight: 600;
      color: #64748b;
      margin-bottom: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .manual-day-number {
      font-size: 0.875rem;
      font-weight: 700;
      color: #1e293b;
    }

    .manual-day-content {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-height: 40px;
    }

    .manual-shift-assigned {
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.75rem;
      font-weight: 600;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .manual-shift-assigned:hover {
      transform: scale(1.05);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .manual-shift-assigned .remove-shift {
      display: inline-block;
      margin-left: 4px;
      opacity: 0.7;
      font-size: 0.7rem;
    }

    .manual-shift-assigned:hover .remove-shift {
      opacity: 1;
    }

    .calendar-week-header {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 4px;
      margin-bottom: 8px;
      font-weight: 700;
      font-size: 0.75rem;
      color: #475569;
      text-align: center;
    }

    .calendar-week-day {
      padding: 8px;
      background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
      border-radius: 6px;
    }
  </style>
</head>
<body class="min-h-screen">
  <header class="glass rounded-2xl mx-auto max-w-7xl mt-6 p-5" role="banner">
    <div class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
      <div>
        <h1 class="text-3xl md:text-4xl font-black tracking-tight">üìÖ Simulador de Turnos üêü</h1>
        <p class="text-slate-600 dark:text-slate-300" role="doc-subtitle">Planificaci√≥n con vista horizontal de 3 meses continuos</p>
      </div>
      <div class="flex items-center gap-2 no-print" role="toolbar" aria-label="Herramientas principales">
        <button id="btnHelp" class="px-3 py-2 glass rounded-xl hover:bg-white/60 tooltip" data-tooltip="Ver atajos de teclado" aria-label="Ayuda y atajos de teclado">‚ùì</button>
        <button id="btnUndo" class="px-3 py-2 glass rounded-xl hover:bg-white/60 tooltip" data-tooltip="Deshacer (Ctrl/‚åò+Z)" aria-label="Deshacer">‚Ü©Ô∏è</button>
        <button id="btnRedo" class="px-3 py-2 glass rounded-xl hover:bg-white/60 tooltip" data-tooltip="Rehacer (Ctrl/‚åò+Shift+Z)" aria-label="Rehacer">‚Ü™Ô∏è</button>
        <button id="btnDark" class="px-3 py-2 glass rounded-xl hover:bg-white/60 tooltip" data-tooltip="Cambiar tema" aria-label="Cambiar tema oscuro/claro">üåó</button>
        <button id="btnMobileMenu" class="px-3 py-2 glass rounded-xl hover:bg-white/60 md:hidden" aria-label="Men√∫">‚ò∞</button>
      </div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto mt-6 grid gap-6" role="main">
    <!-- CONFIG -->
    <section class="glass rounded-2xl p-6 config-area" aria-label="Configuraci√≥n">
      <h2 class="text-xl font-extrabold mb-4">‚öôÔ∏è Configuraci√≥n r√°pida</h2>
      <div class="grid sm:grid-cols-2 lg:grid-cols-4 gap-4">
        <div>
          <label for="startDate" class="block text-sm font-semibold mb-2">Fecha inicio</label>
          <input type="date" id="startDate" aria-label="Fecha de inicio de planificaci√≥n" class="w-full px-3 py-2 rounded-xl border border-slate-200 focus:ring-2 focus:ring-indigo-400" />
        </div>
        <div>
          <label for="endDate" class="block text-sm font-semibold mb-2">Fecha fin</label>
          <input type="date" id="endDate" aria-label="Fecha de fin de planificaci√≥n" class="w-full px-3 py-2 rounded-xl border border-slate-200 focus:ring-2 focus:ring-indigo-400" />
        </div>
        <div>
          <label for="visibleMonth" class="block text-sm font-semibold mb-2">Navegaci√≥n de meses</label>
          <div class="flex gap-2 items-center">
            <button id="btnPrevMonth" class="nav-btn glass px-3 py-2 rounded-xl hover:bg-white/60" aria-label="Mes anterior">‚óÄ</button>
            <select id="visibleMonth" aria-label="Seleccionar mes visible" class="flex-1 px-3 py-2 rounded-xl border border-slate-200 focus:ring-2 focus:ring-indigo-400"></select>
            <button id="btnNextMonth" class="nav-btn glass px-3 py-2 rounded-xl hover:bg-white/60" aria-label="Mes siguiente">‚ñ∂</button>
          </div>
          <div id="breadcrumbRange" class="breadcrumb mt-2 text-center" role="status" aria-live="polite"></div>
        </div>
        <div class="flex gap-2 items-end">
          <button id="btnExportXLSX" class="flex-1 bg-emerald-600 text-white font-bold py-2 px-4 rounded-xl hover:bg-emerald-700" aria-label="Exportar planificaci√≥n a Excel">üì• Exportar Excel</button>
          <button id="btnPrint" class="px-4 py-2 rounded-xl border border-slate-200 hover:bg-white/60" aria-label="Imprimir planificaci√≥n">üñ®Ô∏è Imprimir</button>
        </div>
      </div>
      <div class="mt-4 flex flex-wrap gap-2 no-print items-center">
        <button id="btnSave" class="px-3 py-2 glass rounded-xl" aria-label="Guardar configuraci√≥n">üíæ Guardar</button>
        <button id="btnLoad" class="px-3 py-2 glass rounded-xl" aria-label="Cargar configuraci√≥n guardada">üìÇ Cargar</button>
        <button id="btnReset" class="px-3 py-2 glass rounded-xl text-rose-700" aria-label="Resetear a configuraci√≥n inicial">üßπ Reset</button>
      </div>
    </section>

    <!-- NAVEGACI√ìN PRINCIPAL DE MODOS - COMPACTO -->
    <div class="flex justify-center mb-6 no-print" aria-label="Selecci√≥n de modo">
      <div class="inline-flex glass rounded-xl p-1 gap-1">
        <button id="btnModeAuto" class="mode-nav-btn px-6 py-2 rounded-lg font-semibold text-sm transition-all bg-indigo-500 text-white shadow-sm" data-mode="auto">
          ü§ñ Autom√°tico
        </button>
        <button id="btnModeManual" class="mode-nav-btn px-6 py-2 rounded-lg font-semibold text-sm transition-all bg-transparent text-slate-700 hover:bg-white/50" data-mode="manual">
          ‚úèÔ∏è Manual
        </button>
      </div>
    </div>

    <!-- ========== SECCI√ìN MODO AUTOM√ÅTICO ========== -->
    <div id="sectionAuto" class="mode-section">
      <!-- GROUPS PALETTE - AUTOM√ÅTICO -->
      <section class="glass rounded-2xl p-6 groups-palette" aria-label="Paleta de grupos - Modo autom√°tico">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-xl font-extrabold">üë• Grupos disponibles</h2>
          <div class="text-slate-500 text-sm flex items-center gap-2">
            <span class="hidden md:inline">üëÜ Arrastra una ficha de ciclo a un turno</span>
            <button id="btnTutorial" class="text-indigo-600 hover:text-indigo-800 font-semibold" aria-label="Ver tutorial de uso">Ver tutorial</button>
          </div>
        </div>
        <div id="groupsPalette" class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-8 gap-3" role="list"></div>
      </section>

      <!-- DROP ZONES - AUTOM√ÅTICO -->
      <section class="grid md:grid-cols-3 gap-6 zones-area" aria-label="Zonas de turnos - Modo autom√°tico">
        <div class="glass rounded-2xl p-5" id="zone-day" data-drop-zone="day" role="region" aria-label="Turno d√≠a"></div>
        <div class="glass rounded-2xl p-5" id="zone-afternoon" data-drop-zone="afternoon" role="region" aria-label="Turno tarde"></div>
        <div class="glass rounded-2xl p-5" id="zone-night" data-drop-zone="night" role="region" aria-label="Turno noche"></div>
      </section>

      <!-- TABS - AUTOM√ÅTICO -->
      <section class="grid gap-4 tabs-area">
        <div class="flex flex-wrap gap-2 no-print" role="tablist" aria-label="Vistas del calendario - Modo autom√°tico">
          <button class="tab-btn px-3 py-2 glass rounded-xl font-semibold" data-tab="by-group" role="tab" aria-controls="tabContent">üë• Vista por grupos</button>
          <button class="tab-btn px-3 py-2 glass rounded-xl font-semibold" data-tab="by-shift" role="tab" aria-controls="tabContent">üìä Vista por turnos</button>
          <button class="tab-btn px-3 py-2 glass rounded-xl font-semibold" data-tab="stats" role="tab" aria-controls="tabContent">üìà M√©tricas & domingos</button>
          <button class="tab-btn px-3 py-2 glass rounded-xl font-semibold" data-tab="rules" role="tab" aria-controls="tabContent">‚úÖ Validador de reglas</button>
        </div>
        <div id="tabContent" class="glass rounded-2xl p-4 overflow-x-auto" role="tabpanel"></div>
        <div class="print:show text-xs text-slate-500">Generado por Simulador de Turnos PRO v2</div>
      </section>
    </div>

    <!-- ========== SECCI√ìN MODO MANUAL ========== -->
    <div id="sectionManual" class="mode-section" style="display: none;">
      <!-- INTERFAZ DE CONSTRUCCI√ìN MANUAL -->
      <section class="glass rounded-2xl p-4" aria-label="Construcci√≥n manual de turnos">
        <div class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-extrabold">‚úèÔ∏è Construcci√≥n Manual</h2>
          <div class="text-slate-500 text-xs">
            <span class="hidden md:inline">Asigna turnos d√≠a por d√≠a</span>
          </div>
        </div>
        <div id="manualInterface" class="space-y-4">
          <!-- La interfaz manual se renderizar√° aqu√≠ din√°micamente -->
        </div>
      </section>

      <!-- TABS - MANUAL -->
      <section class="grid gap-3 tabs-area">
        <div class="flex flex-wrap gap-2 items-center justify-between no-print" role="tablist" aria-label="Vistas del calendario - Modo manual">
          <!-- Pesta√±as a la izquierda -->
          <div class="flex flex-wrap gap-2">
            <button class="tab-btn-manual px-3 py-2 glass rounded-xl font-semibold" data-tab="by-group" role="tab" aria-controls="tabContentManual">üë• Vista por grupos</button>
            <button class="tab-btn-manual px-3 py-2 glass rounded-xl font-semibold" data-tab="by-shift" role="tab" aria-controls="tabContentManual">üìä Vista por turnos</button>
            <button class="tab-btn-manual px-3 py-2 glass rounded-xl font-semibold" data-tab="stats" role="tab" aria-controls="tabContentManual">üìà M√©tricas</button>
          </div>

          <!-- Botones de acci√≥n a la derecha -->
          <div class="flex gap-2">
            <button onclick="clearManualCalendar()" class="px-3 py-2 bg-rose-500 text-white rounded-xl font-semibold hover:bg-rose-600 text-sm" title="Limpiar todo el calendario">
              üóëÔ∏è Limpiar
            </button>
            <button id="btnUndoManual" onclick="undo()" class="px-3 py-2 glass rounded-xl font-semibold hover:bg-white/60 text-sm" title="Deshacer (Ctrl/‚åò+Z)">
              ‚Ü©Ô∏è
            </button>
            <button id="btnRedoManual" onclick="redo()" class="px-3 py-2 glass rounded-xl font-semibold hover:bg-white/60 text-sm" title="Rehacer (Ctrl/‚åò+Shift+Z)">
              ‚Ü™Ô∏è
            </button>
          </div>
        </div>
        <div id="tabContentManual" class="glass rounded-2xl p-4 overflow-x-auto" role="tabpanel"></div>
        <div class="print:show text-xs text-slate-500">Generado por Simulador de Turnos PRO v2</div>
      </section>
    </div>
  </main>

  <!-- Modal de ayuda -->
  <div id="helpModal" class="hidden"></div>

  <!-- Modal de tutorial -->
  <div id="tutorialModal" class="hidden"></div>

  <!-- Modal de vista previa -->
  <div id="previewModal" class="hidden"></div>

  <!-- √Årea para imprimir -->
  <div id="printArea" class="hidden">
    <div class="p-6">
      <h2 class="text-2xl font-extrabold mb-2">Distribuci√≥n de Grupos</h2>
      <div id="printZones"></div>
      <h2 class="text-2xl font-extrabold mt-6 mb-2">Calendario ‚Äî Vista por grupos</h2>
      <div id="printByGroup"></div>
      <h2 class="text-2xl font-extrabold mt-6 mb-2">Calendario ‚Äî Vista por turnos</h2>
      <div id="printByShift"></div>
    </div>
  </div>

  <template id="tpl-zone">
    <div class="min-h-[420px]">
      <h3 class="text-2xl font-extrabold mb-2 text-center"></h3>
      <div class="text-center text-sm text-slate-600 mb-4">(<span class="js-count"></span>/<span class="js-cap"></span> grupos)</div>
      <div class="space-y-3 js-cards"></div>
      <div class="js-empty hidden border-2 border-dashed rounded-xl py-10 text-center text-slate-500">Arrastra aqu√≠ para asignar</div>
    </div>
  </template>

  <script>
    // ---------- STATE ----------
    const defaultState = {
      startDate: '2025-10-01',
      endDate:   '2027-09-30',
      selectedMonth: null, // se sincroniza con startDate en init y en cambios
      maxGroupsPerShift: 4,
      groups: ['1','2','3','4','A2','B2','C2','D2'],
      groupNames: {
        '1': 'Grupo 1',
        '2': 'Grupo 2',
        '3': 'Grupo 3',
        '4': 'Grupo 4',
        'A2': 'Grupo A2',
        'B2': 'Grupo B2',
        'C2': 'Grupo C2',
        'D2': 'Grupo D2'
      },
      shiftAssignments: {
        day:       [{ groupId: '1', cycle1: '6x1', cycle2: null, cycle1Repeat: 1, cycle2Repeat: 1, startOffset: 0 }],
        afternoon: [{ groupId: '2', cycle1: '6x1', cycle2: null, cycle1Repeat: 1, cycle2Repeat: 1, startOffset: 0 }],
        night:     [{ groupId: '3', cycle1: '5x2', cycle2: null, cycle1Repeat: 1, cycle2Repeat: 1, startOffset: 0 }],
      },
      rules: { minFreeSundaysPerMonth: 2, maxConsecutiveWorkDays: 6 },
      manualMode: false, // true = modo manual, false = modo autom√°tico
      selectedShiftType: null, // Tipo de turno seleccionado en modo manual: 'day', 'afternoon', 'night', 'rest'
      selectedGroupId: null, // ID del grupo seleccionado para asignar turnos
      manualDaysByGroup: {}, // { 'groupId': { 'YYYY-MM-DD': 'day' | 'afternoon' | 'night' | 'rest' } }
      manualAssignments: {
        day:       [],
        afternoon: [],
        night:     []
      },
      manualDays: {}, // { 'YYYY-MM-DD': 'day' | 'afternoon' | 'night' | 'rest' }
      manualCalendar: {} // DEPRECATED: mantener para compatibilidad con versiones antiguas
    };

    let state = JSON.parse(JSON.stringify(defaultState));

    // Undo/Redo stacks
    const undoStack = []; const redoStack = [];

    const groupColors = { '1': 'bg-purple-500 text-white','2': 'bg-pink-500 text-white','3': 'bg-blue-500 text-white','4': 'bg-green-500 text-white','A2': 'bg-amber-500 text-white','B2': 'bg-cyan-500 text-white','C2': 'bg-rose-500 text-white','D2': 'bg-teal-500 text-white' };
    const groupBorders = { '1': 'border-purple-500','2': 'border-pink-500','3': 'border-blue-500','4': 'border-green-500','A2': 'border-amber-500','B2': 'border-cyan-500','C2': 'border-rose-500','D2': 'border-teal-500' };

    // Colores HEX para Excel (sin el #)
    const groupColorsHex = {
      '1': 'A855F7',   // purple-500
      '2': 'EC4899',   // pink-500
      '3': '3B82F6',   // blue-500
      '4': '10B981',   // green-500
      'A2': 'F59E0B',  // amber-500
      'B2': '06B6D4',  // cyan-500
      'C2': 'F43F5E',  // rose-500
      'D2': '14B8A6'   // teal-500
    };

    const clone = (o)=> JSON.parse(JSON.stringify(o));

    // ===== GOOGLE APPS SCRIPT HELPERS =====
    // Reemplazan localStorage con Google Sheets

    /**
     * Guardar estado en Google Sheets (reemplaza localStorage.setItem)
     */
    async function saveToSheets() {
      if (typeof google === 'undefined' || !google.script || !google.script.run) {
        toast('‚ö†Ô∏è Google Apps Script no disponible', 'error');
        return;
      }

      try {
        const stateJSON = JSON.stringify(state);
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(response => {
              if (response.success) {
                toast('üíæ Guardado en Google Sheets', 'success');
                resolve(response);
              } else {
                toast('‚ö†Ô∏è Error al guardar: ' + response.error, 'error');
                reject(new Error(response.error));
              }
            })
            .withFailureHandler(error => {
              toast('‚ö†Ô∏è Error al guardar: ' + error.message, 'error');
              reject(error);
            })
            .saveState(stateJSON);
        });
      } catch (error) {
        toast('‚ö†Ô∏è Error: ' + error.message, 'error');
        throw error;
      }
    }

    /**
     * Cargar estado desde Google Sheets (reemplaza localStorage.getItem)
     */
    async function loadFromSheets() {
      if (typeof google === 'undefined' || !google.script || !google.script.run) {
        toast('‚ö†Ô∏è Google Apps Script no disponible', 'error');
        return;
      }

      try {
        return new Promise((resolve, reject) => {
          google.script.run
            .withSuccessHandler(response => {
              if (response.success && response.data) {
                pushHistory();
                state = JSON.parse(response.data);
                renderAll();
                toast('üìÇ Configuraci√≥n cargada', 'success');
                resolve(state);
              } else {
                toast('‚ö†Ô∏è No hay guardado previo', 'error');
                reject(new Error(response.message || 'No hay estado guardado'));
              }
            })
            .withFailureHandler(error => {
              toast('‚ö†Ô∏è Error al cargar: ' + error.message, 'error');
              reject(error);
            })
            .loadState();
        });
      } catch (error) {
        toast('‚ö†Ô∏è Error: ' + error.message, 'error');
        throw error;
      }
    }

    /**
     * Autoguardado (sin notificaci√≥n) - fire and forget
     */
    const saveAuto = () => {
      if (typeof google === 'undefined' || !google.script || !google.script.run) {
        return; // Silenciosamente no hacer nada si no est√° disponible
      }

      try {
        const stateJSON = JSON.stringify(state);
        google.script.run
          .withSuccessHandler(() => {
            // Silencioso - no mostrar toast
          })
          .withFailureHandler(error => {
            console.error('Error en autoguardado:', error);
          })
          .saveState(stateJSON);
      } catch (error) {
        console.error('Error en autoguardado:', error);
      }
    };
    const pushHistory = ()=>{ undoStack.push(clone(state)); redoStack.length = 0; };

    // ---------- UTILS ----------
    const cycleTuple = (t)=> ({'4x3':[4,3],'5x2':[5,2],'6x1':[6,1]})[t];
    const daysInMonth = (yyyyMM)=>{ const [y,m] = yyyyMM.split('-').map(Number); const count=new Date(y,m,0).getDate(); const arr=[]; for(let d=1; d<=count; d++){ const iso=`${yyyyMM}-${String(d).padStart(2,'0')}`; const dt=new Date(iso); arr.push({date:iso, js:dt, isSunday: dt.getDay()===0}); } return arr; };

    function buildEngine(){
      // Parsear fechas evitando problemas de zona horaria
      const [startY, startM, startD] = state.startDate.split('-').map(Number);
      const [endY, endM, endD] = state.endDate.split('-').map(Number);
      const start = new Date(startY, startM - 1, startD);
      const end = new Date(endY, endM - 1, endD);

      const calendar={ day:[], afternoon:[], night:[] }; const byGroup={}; const engine={};
      ['day','afternoon','night'].forEach(shift=>{
        state.shiftAssignments[shift].forEach(a=>{
          if(!engine[a.groupId]){
            const c1=cycleTuple(a.cycle1); const c2=a.cycle2?cycleTuple(a.cycle2):null; const span=c1[0]+c1[1]; const startCycle=(a.startOffset||0)%span;
            engine[a.groupId]={ shift, cycle1:a.cycle1, cycle2:a.cycle2, c1Work:c1[0], c1Span:c1[0]+c1[1], c2Work:c2?c2[0]:null, c2Span:c2?c2[0]+c2[1]:null, cycleDay:startCycle, cycleType:1, reps:0 };
            byGroup[a.groupId]=[];
          }
        });
      });
      const currentDate = new Date(start);
      while(currentDate <= end){
        const y = currentDate.getFullYear();
        const m = String(currentDate.getMonth() + 1).padStart(2, '0');
        const d = String(currentDate.getDate()).padStart(2, '0');
        const dateStr = `${y}-${m}-${d}`;
        const isSunday = currentDate.getDay()===0;
        const row = { day:{date:dateStr,isSunday,groups:[]}, afternoon:{date:dateStr,isSunday,groups:[]}, night:{date:dateStr,isSunday,groups:[]} };
        Object.keys(engine).forEach(g=>{
          const e=engine[g]; const workDays=e.cycleType===1?e.c1Work:e.c2Work; const span=e.cycleType===1?e.c1Span:e.c2Span; const isWork=e.cycleDay<workDays;
          row[e.shift].groups.push({groupId:g,isWorking:isWork,currentCycleType:e.cycleType});
          byGroup[g].push({date:dateStr,isSunday,isWorking:isWork,shift:isWork?e.shift:'rest',currentCycleType:e.cycleType});
          e.cycleDay++; if(e.cycleDay>=span){ e.cycleDay=0; e.reps++; if(e.cycle2){ e.cycleType = e.cycleType===1?2:1; e.reps=0; } e.shift = e.shift==='day'? 'afternoon' : e.shift==='afternoon'? 'night' : 'day'; }
        });
        calendar.day.push(row.day); calendar.afternoon.push(row.afternoon); calendar.night.push(row.night);
        currentDate.setDate(currentDate.getDate()+1);
      }
      return {calendar, byGroup};
    }

    function buildManualCalendar(){
      // Parsear fechas evitando problemas de zona horaria
      const [startY, startM, startD] = state.startDate.split('-').map(Number);
      const [endY, endM, endD] = state.endDate.split('-').map(Number);
      const start = new Date(startY, startM - 1, startD);
      const end = new Date(endY, endM - 1, endD);

      const calendar={ day:[], afternoon:[], night:[] };

      // Asegurarse de que manualDaysByGroup existe
      if (!state.manualDaysByGroup) {
        state.manualDaysByGroup = {};
      }

      // Generar calendario d√≠a por d√≠a usando manualDaysByGroup
      const currentDate1 = new Date(start);
      while(currentDate1 <= end){
        const y = currentDate1.getFullYear();
        const m = String(currentDate1.getMonth() + 1).padStart(2, '0');
        const d = String(currentDate1.getDate()).padStart(2, '0');
        const dateStr = `${y}-${m}-${d}`;
        const isSunday = currentDate1.getDay()===0;

        const row = {
          day:{date:dateStr,isSunday,groups:[]},
          afternoon:{date:dateStr,isSunday,groups:[]},
          night:{date:dateStr,isSunday,groups:[]}
        };

        // Para cada grupo, verificar si tiene un turno asignado ese d√≠a
        state.groups.forEach(groupId => {
          const groupDays = state.manualDaysByGroup[groupId] || {};
          const assignedShift = groupDays[dateStr] || 'rest';

          if(assignedShift !== 'rest'){
            row[assignedShift].groups.push({
              groupId: groupId,
              isWorking:true,
              currentCycleType:1
            });
          }
        });

        calendar.day.push(row.day);
        calendar.afternoon.push(row.afternoon);
        calendar.night.push(row.night);

        currentDate1.setDate(currentDate1.getDate()+1);
      }

      // Para byGroup, crear datos para cada grupo con sus turnos espec√≠ficos
      const byGroup = {};

      // Inicializar cada grupo con sus propios turnos
      state.groups.forEach(groupId => {
        byGroup[groupId] = [];
        const groupDays = state.manualDaysByGroup[groupId] || {};

        // Crear una nueva copia de la fecha de inicio para cada grupo
        const currentDate2 = new Date(start);
        while(currentDate2 <= end){
          const y = currentDate2.getFullYear();
          const m = String(currentDate2.getMonth() + 1).padStart(2, '0');
          const d = String(currentDate2.getDate()).padStart(2, '0');
          const dateStr = `${y}-${m}-${d}`;
          const isSunday = currentDate2.getDay()===0;
          const assignedShift = groupDays[dateStr] || 'rest';

          byGroup[groupId].push({
            date:dateStr,
            isSunday,
            isWorking: assignedShift !== 'rest',
            shift: assignedShift,
            currentCycleType:1
          });

          currentDate2.setDate(currentDate2.getDate()+1);
        }
      });

      return {calendar, byGroup};
    }


    const monthsAvailable = (calendar)=>{ const set=new Set(); calendar.day.forEach(d=>set.add(d.date.slice(0,7))); return Array.from(set).sort(); };
    function monthByGroup(byGroup, yyyyMM){ const days=daysInMonth(yyyyMM); const out={}; Object.keys(byGroup).forEach(g=>{ const map=new Map(byGroup[g].map(d=>[d.date,d])); out[g]=days.map(x=> map.get(x.date) || {date:x.date,isSunday:x.isSunday,shift:'rest',isWorking:false,currentCycleType:1}); }); return out; }
    function monthByShift(calendar, yyyyMM){ const start=`${yyyyMM}-01`; const endDt=daysInMonth(yyyyMM).slice(-1)[0].date; const sliced={day:[],afternoon:[],night:[]}; ['day','afternoon','night'].forEach(k=>{ sliced[k]=calendar[k].filter(d=> d.date>=start && d.date<=endDt); }); return sliced; }

    // Funci√≥n para detectar la pesta√±a activa
    const currentTab=()=> document.querySelector('.tab-btn.bg-white\\/60')?.dataset.tab || 'by-group';

    // ---------- RENDER ----------
    function renderAll(){
      // Usar calendario manual o autom√°tico seg√∫n el modo
      const {calendar, byGroup} = state.manualMode ? buildManualCalendar() : buildEngine();
      if(!state.selectedMonth){ state.selectedMonth = state.startDate.slice(0,7); }
      const select = document.getElementById('visibleMonth');
      const opts = monthsAvailable(calendar);
      // Si el mes seleccionado no est√° en las opciones, usar startDate en vez del primer mes disponible
      if(!opts.includes(state.selectedMonth)) state.selectedMonth = state.startDate.slice(0,7);
      select.innerHTML = opts.map(m=>`<option value="${m}" ${m===state.selectedMonth?'selected':''}>${new Date(m+'-01').toLocaleDateString('es-CL',{month:'long',year:'numeric'})}</option>`).join('');

      const pal = document.getElementById('groupsPalette');
      pal.innerHTML = state.groups.map(g=>{
        return `<div class="space-y-2">
          <div class="${groupColors[g]} rounded-xl p-2 text-center font-bold">${getGroupDisplayName(g)}</div>
          ${['4x3','5x2','6x1'].map(c=>`<div draggable="true" data-group="${g}" data-cycle="${c}" class="draggable-item border-2 ${groupBorders[g]} bg-white rounded-xl p-2 text-center font-semibold text-xs" title="Arrastra al turno deseado">‚ãÆ‚ãÆ ${c}</div>`).join('')}
        </div>`;
      }).join('');

      const packs=[{id:'zone-day', key:'day', title:'‚òÄÔ∏è D√çA', color:'text-amber-900'},{id:'zone-afternoon', key:'afternoon', title:'üå§Ô∏è TARDE', color:'text-orange-900'},{id:'zone-night', key:'night', title:'üåô NOCHE', color:'text-indigo-900'}];
      packs.forEach(p=>{
        const host=document.getElementById(p.id); const tpl=document.getElementById('tpl-zone').content.cloneNode(true);
        tpl.querySelector('h3').className=`text-2xl font-extrabold mb-2 text-center ${p.color}`; tpl.querySelector('h3').textContent=p.title;
        tpl.querySelector('.js-cap').textContent=state.maxGroupsPerShift; const cards=tpl.querySelector('.js-cards');
        // Usar asignaciones manuales o autom√°ticas seg√∫n el modo
        const list=state.manualMode ? state.manualAssignments[p.key] : state.shiftAssignments[p.key];
        tpl.querySelector('.js-count').textContent=list.length; tpl.querySelector('.js-empty').classList.toggle('hidden', list.length>0);
        cards.innerHTML=list.map((a,idx)=>{
          return `<div class="border-2 ${groupBorders[a.groupId]} bg-white rounded-xl p-3">
            <div class="flex items-center justify-between mb-2">
              <span class="${groupColors[a.groupId]} chip">G${a.groupId}</span>
              <div class="flex gap-2">
                <button data-action="dup" data-shift="${p.key}" data-idx="${idx}" class="text-slate-500 hover:text-slate-700" title="Duplicar">‚éò</button>
                <button data-action="del" data-shift="${p.key}" data-idx="${idx}" class="text-rose-600 hover:text-rose-800" title="Eliminar">üóëÔ∏è</button>
              </div>
            </div>
            <div class="grid grid-cols-2 gap-2">
              <label class="text-xs font-semibold">Ciclo 1
                <select data-action="c1" data-shift="${p.key}" data-idx="${idx}" class="w-full px-2 py-1 border rounded text-sm">
                  ${['4x3','5x2','6x1'].map(c=>`<option value="${c}" ${a.cycle1===c?'selected':''}>${c}</option>`).join('')}
                </select>
              </label>
              <label class="text-xs font-semibold">Ciclo 2
                <select data-action="c2" data-shift="${p.key}" data-idx="${idx}" class="w-full px-2 py-1 border rounded text-sm">
                  <option value="">Sin ciclo 2</option>
                  ${['4x3','5x2','6x1'].map(c=>`<option value="${c}" ${a.cycle2===c?'selected':''}>${c}</option>`).join('')}
                </select>
              </label>
              <label class="text-xs font-semibold">Desfase
                <input type="number" min="0" max="30" value="${a.startOffset||0}" data-action="ofs" data-shift="${p.key}" data-idx="${idx}" class="w-full px-2 py-1 border rounded text-sm" />
              </label>
              <label class="text-xs font-semibold">Repeticiones C1
                <select data-action="r1" data-shift="${p.key}" data-idx="${idx}" class="w-full px-2 py-1 border rounded text-sm">
                  ${[1,2,3].map(n=>`<option value="${n}" ${a.cycle1Repeat===n?'selected':''}>${n}x</option>`).join('')}
                </select>
              </label>
            </div>
          </div>`;
        }).join('');
        host.innerHTML=''; host.appendChild(tpl);
      });

      // Guardar la pesta√±a activa actual antes de renderizar
      const activeTab = currentTab();
      renderTab(activeTab, {calendar, byGroup});
      wireZoneButtons();
    }

    // === NUEVO: render de 3 meses consecutivos para vistas por grupo y por turno ===
    function renderTab(tab, data){
      const wrap=document.getElementById('tabContent');
      const {calendar, byGroup} = data || buildEngine();
      const baseMonth = new Date(state.selectedMonth + '-01');

      // Genera los pr√≥ximos 3 meses
      const months = [];
      const startYear = baseMonth.getFullYear();
      const startMonth = baseMonth.getMonth();
      for (let i = 0; i < 3; i++) {
        const year = startYear + Math.floor((startMonth + i) / 12);
        const month = (startMonth + i) % 12;
        const m = new Date(year, month, 1);
        months.push(m.toISOString().slice(0, 7));
      }

      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('bg-white/60'));
      const activeBtn = document.querySelector(`.tab-btn[data-tab="${tab}"]`);
      if (activeBtn) activeBtn.classList.add('bg-white/60');

      if (tab === 'by-group') {
        // UNA SOLA TABLA con 3 meses lineales
        wrap.innerHTML = htmlByGroup(byGroup, months);
      }

      if (tab === 'by-shift') {
        // UNA SOLA TABLA con 3 meses lineales
        wrap.innerHTML = htmlByShift(calendar, months);
      }

      if (tab === 'stats') {
        const s = sundayStats(calendar, 6);
        const totals = totalsFromSunday(s);
        wrap.innerHTML = renderStats(s, totals);
      }

      if (tab === 'rules') {
        const s = sundayStats(calendar, 6);
        wrap.innerHTML = renderRules(s);
      }

      if (tab === 'manual') {
        wrap.innerHTML = renderManualCalendar();
        // wireManualDnD ya se configur√≥ en init, no llamar aqu√≠
      }
    }

    function renderTabManual(tab){
      const wrap=document.getElementById('tabContentManual');
      const {calendar, byGroup} = buildManualCalendar();
      const baseMonth = new Date(state.selectedMonth + '-01');

      // Genera los pr√≥ximos 3 meses
      const months = [];
      const startYear = baseMonth.getFullYear();
      const startMonth = baseMonth.getMonth();
      for (let i = 0; i < 3; i++) {
        const year = startYear + Math.floor((startMonth + i) / 12);
        const month = (startMonth + i) % 12;
        const m = new Date(year, month, 1);
        months.push(m.toISOString().slice(0, 7));
      }

      document.querySelectorAll('.tab-btn-manual').forEach(b => b.classList.remove('bg-white/60'));
      const activeBtn = document.querySelector(`.tab-btn-manual[data-tab="${tab}"]`);
      if (activeBtn) activeBtn.classList.add('bg-white/60');

      if (tab === 'by-group') {
        // Vista por grupos interactiva para modo manual
        wrap.innerHTML = htmlByGroupInteractive(byGroup, months);
        wireGroupViewClicks();
      }

      if (tab === 'by-shift') {
        // UNA SOLA TABLA con 3 meses lineales
        wrap.innerHTML = htmlByShift(calendar, months);
      }

      if (tab === 'stats') {
        const s = sundayStats(calendar, 6);
        const totals = totalsFromSunday(s);
        wrap.innerHTML = renderStats(s, totals);
      }
    }

    // Vista por grupos interactiva para modo manual
    function htmlByGroupInteractive(byGroup, months) {
      if (typeof months === 'string') {
        const baseMonth = new Date(months + '-01');
        months = [];
        const startYear = baseMonth.getFullYear();
        const startMonth = baseMonth.getMonth();
        for (let i = 0; i < 3; i++) {
          const year = startYear + Math.floor((startMonth + i) / 12);
          const month = (startMonth + i) % 12;
          const m = new Date(year, month, 1);
          months.push(m.toISOString().slice(0, 7));
        }
      }

      const groups = state.groups || [];
      if(groups.length === 0) {
        return `
          <div class="bg-amber-50 border-l-4 border-amber-400 p-4 text-center">
            ‚ö†Ô∏è No hay grupos creados. Haz clic en el bot√≥n "+" para agregar grupos.
          </div>
          <div class="mt-4 p-4 bg-blue-50 border-2 border-blue-300 rounded-xl">
            <p class="text-sm text-slate-700"><strong>üí° Nota:</strong> Esta vista muestra los turnos organizados por grupo usando el calendario manual que has creado d√≠a a d√≠a.</p>
          </div>
        `;
      }

      // Combinar todos los d√≠as de los 3 meses
      const allDays = [];
      months.forEach(month => {
        const days = daysInMonth(month);
        allDays.push(...days);
      });

      // Construir datos por grupo para todos los d√≠as
      const mg = {};
      groups.forEach(g => {
        if (byGroup[g]) {
          const map = new Map(byGroup[g].map(d => [d.date, d]));
          mg[g] = allDays.map(x => map.get(x.date) || {date: x.date, isSunday: x.isSunday, shift: 'rest', isWorking: false, currentCycleType: 1});
        } else {
          // Si el grupo no tiene datos en byGroup, crear d√≠as vac√≠os
          mg[g] = allDays.map(x => ({date: x.date, isSunday: x.isSunday, shift: 'rest', isWorking: false, currentCycleType: 1}));
        }
      });

      return `
      <div class="mb-4 p-4 bg-blue-50 border-2 border-blue-300 rounded-xl">
        <div class="flex items-center justify-between mb-2">
          <div class="flex-1">
            <p class="text-sm text-slate-700"><strong>üí° Vista interactiva:</strong> Selecciona un grupo y un turno, luego haz clic en cualquier celda para asignarlo.</p>
            <div class="flex items-center gap-4 mt-2">
              <div>
                <span class="text-xs text-slate-500">Grupo actual: </span>
                <strong id="currentGroupLabel" class="text-sm">Ninguno seleccionado</strong>
              </div>
              <div>
                <span class="text-xs text-slate-500">Turno actual: </span>
                <strong id="currentShiftLabel" class="text-sm">Ninguno seleccionado</strong>
              </div>
            </div>
          </div>
          <button onclick="addNewGroup()" class="bg-green-500 hover:bg-green-600 text-white rounded-full w-10 h-10 flex items-center justify-center text-2xl font-bold shadow-lg transition-all hover:scale-110" title="Agregar nuevo grupo">
            +
          </button>
        </div>
      </div>
      <div class="scroll-hint">
        <span>‚û°Ô∏è Desliza horizontalmente para ver los ${allDays.length} d√≠as de ${months.length} meses</span>
      </div>
      <div class="calendar-container">
      <table class="border-collapse text-xs" style="width: auto; min-width: max-content;">
        <thead>
          <tr class="bg-slate-100">
            <th class="sticky-left border p-2 font-bold bg-slate-100">
              <div>Grupo</div>
              <div class="text-[10px] text-slate-500 font-normal mt-1">(Clic para editar)</div>
            </th>
            ${allDays.map(d => {
              const isFirst = d.js.getDate() === 1;
              const mon = d.js.toLocaleDateString('es-CL', {month: 'short'}).toUpperCase();
              return `<th class="border p-1 ${d.isSunday ? 'bg-blue-100' : ''} ${isFirst ? 'border-l-4 border-l-rose-500' : ''}">
                ${isFirst ? `<div class="text-rose-600 font-bold text-[10px]">${mon}</div>` : ''}
                <div class="font-bold">${d.js.getDate()}</div>
                <div class="text-[10px]">${d.js.toLocaleDateString('es-CL', {weekday: 'short'})}</div>
              </th>`;
            }).join('')}
          </tr>
        </thead>
        <tbody>
          ${groups.map(g => `
            <tr>
              <td class="sticky-left border p-2 bg-white">
                <div class="${groupColors[g] || 'bg-gray-500 text-white'} rounded py-2 px-2 text-center text-sm font-bold cursor-pointer hover:opacity-80 transition-all relative group ${state.selectedGroupId === g ? 'ring-4 ring-blue-500' : ''}" onclick="selectGroupForAssignment('${g}')" title="Clic para seleccionar grupo">
                  <div class="flex items-center justify-between gap-2">
                    <span class="flex-1">${getGroupDisplayName(g)}</span>
                    <button onclick="event.stopPropagation(); showGroupMenu('${g}')" class="opacity-0 group-hover:opacity-100 text-white hover:text-red-200 text-xs font-bold" title="Men√∫ del grupo">
                      ‚ãÆ
                    </button>
                  </div>
                </div>
              </td>
              ${mg[g].map(x => {
                const cls = x.shift === 'day' ? 'shift-day' : x.shift === 'afternoon' ? 'shift-afternoon' : x.shift === 'night' ? 'shift-night' : 'shift-rest';
                const label = x.shift === 'day' ? 'D√≠a' : x.shift === 'afternoon' ? 'Tarde' : x.shift === 'night' ? 'Noche' : 'Descanso';
                return `<td class="border p-1 text-center ${cls} relative cursor-pointer hover:ring-2 hover:ring-blue-500 transition-all manual-group-cell" data-date="${x.date}" data-group="${g}" title="${label}">
                  <div class="font-semibold text-[11px] py-1">${label}${x.currentCycleType === 2 ? '<span class="badge">C2</span>' : ''}</div>
                </td>`;
              }).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
      </div>`;
    }

    // Obtener nombre de grupo para mostrar
    function getGroupDisplayName(groupId) {
      return state.groupNames?.[groupId] || `Grupo ${groupId}`;
    }

    // Seleccionar grupo para asignaci√≥n
    function selectGroupForAssignment(groupId) {
      state.selectedGroupId = groupId;
      updateGroupLabel();
      renderTabManual('by-group');
    }

    // Actualizar label del grupo seleccionado
    function updateGroupLabel() {
      const labelElem = document.getElementById('currentGroupLabel');
      if (labelElem && state.selectedGroupId) {
        labelElem.textContent = getGroupDisplayName(state.selectedGroupId);
        labelElem.className = 'text-sm font-bold text-blue-600';
      } else if (labelElem) {
        labelElem.textContent = 'Ninguno seleccionado';
        labelElem.className = 'text-sm font-bold text-slate-500';
      }
    }

    // Mostrar men√∫ de grupo
    function showGroupMenu(groupId) {
      const groupName = getGroupDisplayName(groupId);
      const options = `
        <div class="space-y-2">
          <button onclick="editGroupName('${groupId}'); this.closest('.modal-overlay').remove();" class="w-full bg-blue-500 text-white px-4 py-2 rounded-xl font-bold hover:bg-blue-600">
            ‚úèÔ∏è Editar nombre
          </button>
          <button onclick="clearGroupCalendar('${groupId}'); this.closest('.modal-overlay').remove();" class="w-full bg-orange-500 text-white px-4 py-2 rounded-xl font-bold hover:bg-orange-600">
            üßπ Limpiar turnos del grupo
          </button>
          <button onclick="deleteGroup('${groupId}'); this.closest('.modal-overlay').remove();" class="w-full bg-red-500 text-white px-4 py-2 rounded-xl font-bold hover:bg-red-600">
            üóëÔ∏è Eliminar grupo
          </button>
          <button onclick="this.closest('.modal-overlay').remove();" class="w-full bg-gray-500 text-white px-4 py-2 rounded-xl font-bold hover:bg-gray-600">
            Cancelar
          </button>
        </div>
      `;
      showModal(`üìã ${groupName}`, options);
    }

    // Limpiar calendario de un grupo espec√≠fico
    function clearGroupCalendar(groupId) {
      const groupName = getGroupDisplayName(groupId);

      if (!confirm(`¬øEst√°s seguro de que deseas limpiar todos los turnos de "${groupName}"?`)) {
        return;
      }

      pushHistory();

      // Limpiar solo los turnos de este grupo
      if (state.manualDaysByGroup) {
        state.manualDaysByGroup[groupId] = {};
      }

      saveAuto();
      renderTabManual('by-group');
      toast(`üßπ Turnos de "${groupName}" limpiados`, 'info');
    }

    // Conectar clics en la vista por grupos
    function wireGroupViewClicks() {
      // Actualizar labels
      const updateLabels = () => {
        const labels = {
          day: '‚òÄÔ∏è D√çA',
          afternoon: 'üå§Ô∏è TARDE',
          night: 'üåô NOCHE',
          rest: 'üèñÔ∏è DESCANSO'
        };
        const labelElem = document.getElementById('currentShiftLabel');
        if (labelElem && state.selectedShiftType) {
          labelElem.textContent = labels[state.selectedShiftType] || 'Ninguno seleccionado';
          labelElem.className = 'text-sm font-bold text-blue-600';
        } else if (labelElem) {
          labelElem.textContent = 'Ninguno seleccionado';
          labelElem.className = 'text-sm font-bold text-slate-500';
        }

        updateGroupLabel();
      };

      updateLabels();

      // Agregar evento de clic a cada celda
      document.querySelectorAll('.manual-group-cell').forEach(cell => {
        cell.addEventListener('click', () => {
          const dateStr = cell.dataset.date;
          const groupId = cell.dataset.group;

          if (dateStr && groupId) {
            // Seleccionar el grupo autom√°ticamente al hacer clic en su celda
            state.selectedGroupId = groupId;
            assignManualDay(dateStr);
            // Recargar la vista por grupos despu√©s de asignar
            setTimeout(() => renderTabManual('by-group'), 100);
          }
        });
      });
    }


    // Seleccionar tipo de turno con bloque
    function selectShiftBlock(shiftType, blockType) {
      state.selectedShiftType = shiftType;
      state.selectedBlockType = blockType;

      updateSelectedShiftLabel();
    }

    // Actualizar el label del turno seleccionado
    function updateSelectedShiftLabel() {
      const labels = {
        day: '‚òÄÔ∏è D√çA',
        afternoon: 'üå§Ô∏è TARDE',
        night: 'üåô NOCHE',
        rest: 'üèñÔ∏è DESCANSO'
      };

      const labelElem = document.getElementById('selectedShiftLabel');
      if (labelElem && state.selectedShiftType) {
        let blockDesc = '';
        if (state.selectedBlockType) {
          // Si es un ciclo como 4x3, 5x2, etc.
          if (state.selectedBlockType.includes('x')) {
            blockDesc = ` (${state.selectedBlockType})`;
          } else if (state.selectedBlockType === '6x') {
            blockDesc = ' (6x)';
          } else {
            // Si es un n√∫mero simple (1, 2, 3)
            const num = parseInt(state.selectedBlockType);
            blockDesc = num > 1 ? ` (${num} d√≠as)` : ' (1 d√≠a)';
          }
        }
        labelElem.textContent = labels[state.selectedShiftType] + blockDesc || 'Ninguno';
      }
    }

    // Funci√≥n antigua para compatibilidad
    function selectShiftType(shiftType) {
      selectShiftBlock(shiftType, '1');
    }

    // Asignar turno a un d√≠a espec√≠fico (ahora con soporte para bloques y por grupo)
    function assignManualDay(dateStr) {
      if (!state.selectedShiftType) {
        toast('‚ö†Ô∏è Primero selecciona un tipo de turno', 'error');
        return;
      }

      if (!state.selectedGroupId) {
        toast('‚ö†Ô∏è Primero selecciona un grupo', 'error');
        return;
      }

      pushHistory();

      // Asegurarse de que manualDaysByGroup existe
      if (!state.manualDaysByGroup) {
        state.manualDaysByGroup = {};
      }

      // Asegurarse de que el grupo existe en manualDaysByGroup
      if (!state.manualDaysByGroup[state.selectedGroupId]) {
        state.manualDaysByGroup[state.selectedGroupId] = {};
      }

      const labels = { day: 'D√çA', afternoon: 'TARDE', night: 'NOCHE', rest: 'DESCANSO' };
      const blockType = state.selectedBlockType || '1';
      const groupDays = state.manualDaysByGroup[state.selectedGroupId];

      // Verificar si es un ciclo (4x3, 5x2, 6x1, 6x)
      if (blockType.includes('x')) {
        let workDays, restDays;

        if (blockType === '6x') {
          workDays = 6;
          restDays = 0;
        } else {
          const parts = blockType.split('x');
          workDays = parseInt(parts[0]);
          restDays = parseInt(parts[1]);
        }

        // Aplicar el ciclo desde la fecha seleccionada
        // Usar Date con a√±o, mes, d√≠a para evitar problemas de zona horaria
        const [year, month, day] = dateStr.split('-').map(Number);
        let currentDate = new Date(year, month - 1, day);
        let daysAssigned = 0;

        // Asignar d√≠as de trabajo
        for (let i = 0; i < workDays; i++) {
          const y = currentDate.getFullYear();
          const m = String(currentDate.getMonth() + 1).padStart(2, '0');
          const d = String(currentDate.getDate()).padStart(2, '0');
          const currentDateStr = `${y}-${m}-${d}`;

          groupDays[currentDateStr] = state.selectedShiftType;
          currentDate.setDate(currentDate.getDate() + 1);
          daysAssigned++;
        }

        // Asignar d√≠as de descanso
        for (let i = 0; i < restDays; i++) {
          const y = currentDate.getFullYear();
          const m = String(currentDate.getMonth() + 1).padStart(2, '0');
          const d = String(currentDate.getDate()).padStart(2, '0');
          const currentDateStr = `${y}-${m}-${d}`;

          groupDays[currentDateStr] = 'rest';
          currentDate.setDate(currentDate.getDate() + 1);
          daysAssigned++;
        }

        const groupName = getGroupDisplayName(state.selectedGroupId);
        toast(`‚úÖ ${groupName}: Ciclo ${blockType} aplicado (${workDays} ${labels[state.selectedShiftType]} + ${restDays} descansos)`, 'success');

      } else {
        // Es un n√∫mero simple (1, 2, 3, etc.)
        const numDays = parseInt(blockType);

        // Usar Date con a√±o, mes, d√≠a para evitar problemas de zona horaria
        const [year, month, day] = dateStr.split('-').map(Number);
        let currentDate = new Date(year, month - 1, day);

        for (let i = 0; i < numDays; i++) {
          const y = currentDate.getFullYear();
          const m = String(currentDate.getMonth() + 1).padStart(2, '0');
          const d = String(currentDate.getDate()).padStart(2, '0');
          const currentDateStr = `${y}-${m}-${d}`;

          groupDays[currentDateStr] = state.selectedShiftType;
          currentDate.setDate(currentDate.getDate() + 1);
        }

        const dayWord = numDays === 1 ? 'd√≠a' : 'd√≠as';
        const groupName = getGroupDisplayName(state.selectedGroupId);
        toast(`‚úÖ ${groupName}: ${numDays} ${dayWord} de ${labels[state.selectedShiftType]} asignados`, 'success');
      }

      saveAuto();
      renderTabManual('by-group');
    }

    // Limpiar todo el calendario manual
    function clearManualCalendar() {
      if (confirm('¬øEst√°s seguro de que deseas limpiar todo el calendario manual de TODOS los grupos?\n\nEsta acci√≥n no se puede deshacer.')) {
        pushHistory();

        // Limpiar ambas estructuras de datos
        state.manualDays = {};
        state.manualDaysByGroup = {};

        // Reinicializar manualDaysByGroup para todos los grupos
        state.groups.forEach(groupId => {
          state.manualDaysByGroup[groupId] = {};
        });

        saveAuto();
        renderTabManual('by-group');
        toast('üóëÔ∏è Calendario de todos los grupos limpiado', 'info');
      }
    }

    // Conectar eventos de clic en el calendario
    // ========== GESTI√ìN DE GRUPOS ==========

    // Agregar nuevo grupo
    function addNewGroup() {
      const newGroupId = `G${Date.now().toString(36)}`; // ID √∫nico basado en timestamp

      pushHistory();

      // Agregar el grupo al array
      state.groups.push(newGroupId);

      // Inicializar groupNames si no existe
      if (!state.groupNames) {
        state.groupNames = {};
      }

      // Asignar nombre por defecto
      const groupNumber = state.groups.length;
      state.groupNames[newGroupId] = `Grupo ${groupNumber}`;

      // Asignar un color aleatorio
      const colors = [
        'bg-purple-500 text-white',
        'bg-pink-500 text-white',
        'bg-blue-500 text-white',
        'bg-green-500 text-white',
        'bg-amber-500 text-white',
        'bg-cyan-500 text-white',
        'bg-rose-500 text-white',
        'bg-teal-500 text-white',
        'bg-indigo-500 text-white',
        'bg-lime-500 text-white',
        'bg-orange-500 text-white',
        'bg-violet-500 text-white'
      ];

      if (!groupColors[newGroupId]) {
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        groupColors[newGroupId] = randomColor;
      }

      saveAuto();
      renderTabManual('by-group');
      toast(`‚úÖ Grupo "${state.groupNames[newGroupId]}" agregado`, 'success');
    }

    // Editar nombre de grupo
    function editGroupName(groupId) {
      const currentName = state.groupNames?.[groupId] || `Grupo ${groupId}`;
      const newName = prompt('Ingresa el nuevo nombre para el grupo:', currentName);

      if (newName && newName.trim() !== '' && newName !== currentName) {
        pushHistory();

        // Inicializar groupNames si no existe
        if (!state.groupNames) {
          state.groupNames = {};
        }

        state.groupNames[groupId] = newName.trim();

        saveAuto();
        renderTabManual('by-group');
        toast(`‚úÖ Grupo renombrado a "${newName}"`, 'success');
      }
    }

    // Eliminar grupo
    function deleteGroup(groupId) {
      const groupName = state.groupNames?.[groupId] || `Grupo ${groupId}`;

      if (!confirm(`¬øEst√°s seguro de que deseas eliminar el grupo "${groupName}"?\n\nSe eliminar√°n todos los turnos asignados a este grupo.`)) {
        return;
      }

      pushHistory();

      // Eliminar del array de grupos
      state.groups = state.groups.filter(g => g !== groupId);

      // Eliminar del objeto de nombres
      if (state.groupNames) {
        delete state.groupNames[groupId];
      }

      // Eliminar turnos manuales del grupo
      if (state.manualDaysByGroup) {
        delete state.manualDaysByGroup[groupId];
      }

      // Eliminar asignaciones en modo autom√°tico
      Object.keys(state.shiftAssignments).forEach(shift => {
        state.shiftAssignments[shift] = state.shiftAssignments[shift].filter(
          assignment => assignment.groupId !== groupId
        );
      });

      // Si el grupo eliminado era el seleccionado, limpiar la selecci√≥n
      if (state.selectedGroupId === groupId) {
        state.selectedGroupId = null;
      }

      saveAuto();
      renderTabManual('by-group');
      toast(`üóëÔ∏è Grupo "${groupName}" eliminado`, 'info');
    }

    // ========== FIN GESTI√ìN DE GRUPOS ==========

    function htmlByGroup(byGroup, months){
      // Si months es string (un solo mes), convertir a array de 3 meses
      if (typeof months === 'string') {
        const baseMonth = new Date(months + '-01');
        months = [];
        const startYear = baseMonth.getFullYear();
        const startMonth = baseMonth.getMonth();
        for (let i = 0; i < 3; i++) {
          const year = startYear + Math.floor((startMonth + i) / 12);
          const month = (startMonth + i) % 12;
          const m = new Date(year, month, 1);
          months.push(m.toISOString().slice(0, 7));
        }
      }
      
      const groups = Object.keys(byGroup); 
      if(groups.length === 0) return emptyMsg('Asigna grupos a los turnos para ver el calendario.');
      
      // Combinar todos los d√≠as de los 3 meses
      const allDays = [];
      months.forEach(month => {
        const days = daysInMonth(month);
        allDays.push(...days);
      });

      // Construir datos por grupo para todos los d√≠as
      const mg = {};
      groups.forEach(g => {
        const map = new Map(byGroup[g].map(d => [d.date, d]));
        mg[g] = allDays.map(x => map.get(x.date) || {date: x.date, isSunday: x.isSunday, shift: 'rest', isWorking: false, currentCycleType: 1});
      });

      return `
      <div class="scroll-hint">
        <span>‚û°Ô∏è Desliza horizontalmente para ver los ${allDays.length} d√≠as de ${months.length} meses</span>
      </div>
      <div class="calendar-container">
      <table class="border-collapse text-xs" style="width: auto; min-width: max-content;">
        <thead>
          <tr class="bg-slate-100">
            <th class="sticky-left border p-2 font-bold bg-slate-100">
              <div>Grupo</div>
            </th>
            ${allDays.map(d => {
              const isFirst = d.js.getDate() === 1;
              const mon = d.js.toLocaleDateString('es-CL', {month: 'short'}).toUpperCase();
              return `<th class="border p-1 ${d.isSunday ? 'bg-blue-100' : ''} ${isFirst ? 'border-l-4 border-l-rose-500' : ''}">
                ${isFirst ? `<div class="text-rose-600 font-bold text-[10px]">${mon}</div>` : ''}
                <div class="font-bold">${d.js.getDate()}</div>
                <div class="text-[10px]">${d.js.toLocaleDateString('es-CL', {weekday: 'short'})}</div>
              </th>`;
            }).join('')}
          </tr>
        </thead>
        <tbody>
          ${groups.map(g => `
            <tr>
              <td class="sticky-left border p-2 bg-white">
                <div class="${groupColors[g] || 'bg-gray-500 text-white'} rounded py-2 px-2 text-center text-sm font-bold">
                  ${getGroupDisplayName(g)}
                </div>
              </td>
              ${mg[g].map(x => {
                const cls = x.shift === 'day' ? 'shift-day' : x.shift === 'afternoon' ? 'shift-afternoon' : x.shift === 'night' ? 'shift-night' : 'shift-rest';
                const label = x.shift === 'day' ? 'D√≠a' : x.shift === 'afternoon' ? 'Tarde' : x.shift === 'night' ? 'Noche' : 'Descanso';
                return `<td class="border p-1 text-center ${cls} relative" title="${label}">
                  <div class="font-semibold text-[11px] py-1">${label}${x.currentCycleType === 2 ? '<span class="badge">C2</span>' : ''}</div>
                </td>`;
              }).join('')}
            </tr>
          `).join('')}
        </tbody>
      </table>
      </div>`;
    }

    function htmlByShift(calendar, months){
      // Si se pasa un objeto con day/afternoon/night (m), convertir a formato esperado
      if (typeof months === 'string' || (months && months.day)) {
        const monthStr = typeof months === 'string' ? months : state.selectedMonth;
        const baseMonth = new Date(monthStr + '-01');
        const monthsArray = [];
        const startYear = baseMonth.getFullYear();
        const startMonth = baseMonth.getMonth();
        for (let i = 0; i < 3; i++) {
          const year = startYear + Math.floor((startMonth + i) / 12);
          const month = (startMonth + i) % 12;
          const m = new Date(year, month, 1);
          monthsArray.push(m.toISOString().slice(0, 7));
        }
        months = monthsArray;
      }
      
      // Combinar todos los d√≠as de los 3 meses para cada turno
      const allDaysData = {day: [], afternoon: [], night: []};
      
      months.forEach(month => {
        const monthData = monthByShift(calendar, month);
        ['day', 'afternoon', 'night'].forEach(shift => {
          allDaysData[shift].push(...monthData[shift]);
        });
      });

      if(!allDaysData.day || allDaysData.day.length === 0) return emptyMsg('No hay datos para el per√≠odo seleccionado.');

      const days = allDaysData.day;

      return `
      <div class="scroll-hint">
        <span>‚û°Ô∏è Desliza horizontalmente para ver los ${days.length} d√≠as de ${months.length} meses</span>
      </div>
      <div class="calendar-container">
      <table class="border-collapse text-xs" style="width: auto; min-width: max-content;">
        <thead>
          <tr class="bg-slate-100">
            <th class="sticky-left border p-2 font-bold bg-slate-100">Turno</th>
            ${days.map(d => {
              const dt = new Date(d.date);
              const isFirst = dt.getDate() === 1;
              const mon = dt.toLocaleDateString('es-CL', {month: 'short'}).toUpperCase();
              return `<th class="border p-1 ${d.isSunday ? 'bg-blue-100' : ''} ${isFirst ? 'border-l-4 border-l-rose-500' : ''}">
                ${isFirst ? `<div class="text-rose-600 font-bold text-[10px]">${mon}</div>` : ''}
                <div class="font-bold">${dt.getDate()}</div>
                <div class="text-[10px]">${dt.toLocaleDateString('es-CL', {weekday: 'short'})}</div>
              </th>`;
            }).join('')}
          </tr>
        </thead>
        <tbody>
          ${['day', 'afternoon', 'night'].map((shift, idx) => {
            const label = ['‚òÄÔ∏è D√çA', 'üå§Ô∏è TARDE', 'üåô NOCHE'][idx];
            const bg = ['bg-amber-50', 'bg-orange-50', 'bg-indigo-50'][idx];
            const bgSticky = ['bg-amber-100', 'bg-orange-100', 'bg-indigo-100'][idx];
            return `
              <tr class="${bg}">
                <td class="sticky-left border p-2 font-bold ${bgSticky}">${label}</td>
                ${allDaysData[shift].map(d => `
                  <td class="border p-1 text-center">
                    ${d.groups.filter(g => g.isWorking).map(g => `
                      <div class="${groupColors[g.groupId]} cell-mini font-bold py-1 px-1 rounded mb-1 relative">
                        G${g.groupId}${g.currentCycleType === 2 ? '<span class="badge">C2</span>' : ''}
                      </div>
                    `).join('') || '<span class="text-slate-400">-</span>'}
                  </td>
                `).join('')}
              </tr>
            `;
          }).join('')}
        </tbody>
      </table>
      </div>`;
    }

    function sundayStats(calendar, months=6){ const stats={}; const base=new Date(state.startDate); for(let i=0;i<months;i++){ const m=new Date(base); m.setMonth(base.getMonth()+i); const key=m.toISOString().slice(0,7); stats[key]={}; state.groups.forEach(g=> stats[key][g]={working:0,free:0,total:0}); ['day','afternoon','night'].forEach(shift=>{ calendar[shift].filter(d=> d.date.startsWith(key) && d.isSunday).forEach(d=>{ d.groups.forEach(g=>{ if(!stats[key][g.groupId]) return; stats[key][g.groupId].total++; if(g.isWorking) stats[key][g.groupId].working++; else stats[key][g.groupId].free++; }); }); }); } return stats; }
    function totalsFromSunday(stats){ const totals={}; state.groups.forEach(g=> totals[g]={working:0,free:0,total:0}); Object.values(stats).forEach(m=>{ state.groups.forEach(g=>{ totals[g].working+=(m[g]?.working||0); totals[g].free+=(m[g]?.free||0); totals[g].total+=(m[g]?.total||0); }); }); return totals; }

    function renderStats(sundayStatsObj, totalStats){ const months=Object.keys(sundayStatsObj); return `
      <div class="grid gap-6">
        <div class="overflow-x-auto">
          <table class="w-full border-collapse text-xs">
            <thead><tr class="bg-slate-100"><th class="border p-2 font-bold">Mes</th>${state.groups.map(g=>`<th class="border p-2 font-bold"><div class="${groupColors[g]} rounded py-1 px-2 inline-block text-xs">${getGroupDisplayName(g)}</div></th>`).join('')}</tr></thead>
            <tbody>${months.map((m,idx)=>`<tr class="${idx%2===0?'bg-white':'bg-slate-50'}"><td class="border p-2 font-semibold">${new Date(m+'-01').toLocaleDateString('es-CL',{month:'short',year:'numeric'})}</td>${state.groups.map(g=>{ const st=sundayStatsObj[m][g]; if(!st||st.total===0) return `<td class=\"border p-2 text-center\">-</td>`; const ok=st.free>=state.rules.minFreeSundaysPerMonth; return `<td class=\"border p-2 text-center ${ok?'bg-emerald-50':'bg-rose-50'}\"><div class=\"font-bold ${ok?'text-emerald-700':'text-rose-700'}\">${st.free}</div><div class=\"text-[10px] text-slate-600\">/${st.total}</div></td>`; }).join('')}</tr>`).join('')}</tbody>
          </table>
        </div>
      </div>`; }

    function renderRules(s){ const issues=[]; Object.entries(s).forEach(([month,groups])=>{ Object.entries(groups).forEach(([g,st])=>{ if(st&&st.total>0&&st.free<state.rules.minFreeSundaysPerMonth){ issues.push({type:'Domingos',month,group:g,msg:`${getGroupDisplayName(g)} con ${st.free}/${st.total} domingos libres (< ${state.rules.minFreeSundaysPerMonth})`}); } }); }); const htmlIssues = issues.length? issues.map(i=>`<li class="p-2 rounded bg-rose-50 border border-rose-200">${new Date(i.month+'-01').toLocaleDateString('es-CL',{month:'long',year:'numeric'})}: <strong>${i.msg}</strong></li>`).join('') : '<li class="p-2 rounded bg-emerald-50 border border-emerald-200">Sin observaciones por ahora ‚ú®</li>'; return `
      <div class="grid md:grid-cols-3 gap-6">
        <div class="md:col-span-2"><h3 class="text-lg font-bold mb-2">Alertas de reglas</h3><ul class="space-y-2">${htmlIssues}</ul></div>
        <div class="glass rounded-xl p-4"><h4 class="font-bold mb-2">Par√°metros</h4>
          <label class="block text-sm mb-3">M√≠n. domingos libres/mes <input id="ruleSundays" type="number" min="0" max="4" value="${state.rules.minFreeSundaysPerMonth}" class="w-full mt-1 px-3 py-2 rounded-xl border"></label>
          <label class="block text-sm">M√°x. d√≠as consecutivos de trabajo (alerta) <input id="ruleStreak" type="number" min="3" max="12" value="${state.rules.maxConsecutiveWorkDays}" class="w-full mt-1 px-3 py-2 rounded-xl border"></label>
          <div class="text-xs text-slate-500 mt-3">Estas validaciones son referencias operativas configurables. Verifica siempre tu normativa interna/sectorial.</div>
          <button id="btnApplyRules" class="mt-4 w-full bg-indigo-600 text-white rounded-xl py-2 font-bold hover:bg-indigo-700">Aplicar</button>
        </div>
      </div>`; }

    const emptyMsg = (t)=> `<div class="bg-amber-50 border-l-4 border-amber-400 p-4 text-center">‚ö†Ô∏è ${t}</div>`;

    // ---------- MANUAL CALENDAR ----------
    // Renderizar interfaz manual en la secci√≥n separada
    function renderManualInterface() {
      const html = `
        <div class="space-y-4">
          <!-- Selector de tipo de turno para asignaci√≥n manual -->
          <div class="glass rounded-2xl p-4">
            <div class="flex items-center justify-between mb-3">
              <h3 class="text-base font-bold">1Ô∏è‚É£ Asignaci√≥n d√≠a por d√≠a</h3>
              <p class="text-xs text-slate-600">Selecciona turno y clic en calendario ‚Üí</p>
            </div>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
              <!-- Tarjeta D√çA -->
              <div class="shift-card bg-amber-50 border-3 border-amber-500 rounded-xl p-3">
                <div class="text-2xl mb-1 text-center">‚òÄÔ∏è</div>
                <div class="text-base font-bold text-center mb-2">D√çA</div>
                <div class="space-y-1">
                  <button onclick="selectShiftBlock('day', '4x3')" class="w-full bg-white border border-amber-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-amber-100 transition-all">4x3</button>
                  <button onclick="selectShiftBlock('day', '5x2')" class="w-full bg-white border border-amber-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-amber-100 transition-all">5x2</button>
                  <button onclick="selectShiftBlock('day', '6x1')" class="w-full bg-white border border-amber-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-amber-100 transition-all">6x1</button>
                  <button onclick="selectShiftBlock('day', '1')" class="w-full bg-amber-200 border-2 border-amber-500 rounded-lg py-1 px-2 text-xs font-bold hover:bg-amber-300 transition-all">+1 D√≠a</button>
                </div>
              </div>

              <!-- Tarjeta TARDE -->
              <div class="shift-card bg-orange-50 border-3 border-orange-500 rounded-xl p-3">
                <div class="text-2xl mb-1 text-center">üå§Ô∏è</div>
                <div class="text-base font-bold text-center mb-2">TARDE</div>
                <div class="space-y-1">
                  <button onclick="selectShiftBlock('afternoon', '4x3')" class="w-full bg-white border border-orange-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-orange-100 transition-all">4x3</button>
                  <button onclick="selectShiftBlock('afternoon', '5x2')" class="w-full bg-white border border-orange-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-orange-100 transition-all">5x2</button>
                  <button onclick="selectShiftBlock('afternoon', '6x')" class="w-full bg-white border border-orange-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-orange-100 transition-all">6x</button>
                  <button onclick="selectShiftBlock('afternoon', '1')" class="w-full bg-orange-200 border-2 border-orange-500 rounded-lg py-1 px-2 text-xs font-bold hover:bg-orange-300 transition-all">+1 Tarde</button>
                </div>
              </div>

              <!-- Tarjeta NOCHE -->
              <div class="shift-card bg-indigo-50 border-3 border-indigo-500 rounded-xl p-3">
                <div class="text-2xl mb-1 text-center">üåô</div>
                <div class="text-base font-bold text-center mb-2">NOCHE</div>
                <div class="space-y-1">
                  <button onclick="selectShiftBlock('night', '4x3')" class="w-full bg-white border border-indigo-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-indigo-100 transition-all">4x3</button>
                  <button onclick="selectShiftBlock('night', '5x2')" class="w-full bg-white border border-indigo-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-indigo-100 transition-all">5x2</button>
                  <button onclick="selectShiftBlock('night', '6x1')" class="w-full bg-white border border-indigo-400 rounded-lg py-1 px-2 text-xs font-semibold hover:bg-indigo-100 transition-all">6x1</button>
                  <button onclick="selectShiftBlock('night', '1')" class="w-full bg-indigo-200 border-2 border-indigo-500 rounded-lg py-1 px-2 text-xs font-bold hover:bg-indigo-300 transition-all">+1 Noche</button>
                </div>
              </div>

              <!-- Tarjeta DESCANSO -->
              <div class="shift-card bg-green-50 border-3 border-green-500 rounded-xl p-3">
                <div class="text-2xl mb-1 text-center">üèñÔ∏è</div>
                <div class="text-base font-bold text-center mb-2">DESCANSO</div>
                <div class="space-y-1">
                  <button onclick="selectShiftBlock('rest', '1')" class="w-full bg-green-200 border border-green-500 rounded-lg py-1 px-2 text-xs font-bold hover:bg-green-300 transition-all">+1</button>
                  <button onclick="selectShiftBlock('rest', '2')" class="w-full bg-green-200 border border-green-500 rounded-lg py-1 px-2 text-xs font-bold hover:bg-green-300 transition-all">+2</button>
                  <button onclick="selectShiftBlock('rest', '3')" class="w-full bg-green-200 border border-green-500 rounded-lg py-1 px-2 text-xs font-bold hover:bg-green-300 transition-all">+3</button>
                </div>
              </div>
            </div>

            <div class="mt-3 text-center">
              <p class="text-xs text-slate-600">
                <strong>Turno seleccionado:</strong>
                <span id="selectedShiftLabel" class="font-bold text-base">Ninguno</span>
              </p>
            </div>
          </div>
        </div>
      `;

      document.getElementById('manualInterface').innerHTML = html;

      // Resaltar el turno seleccionado si existe
      if (state.selectedShiftType) {
        updateSelectedShiftLabel();
      }

      // Renderizar tabs del modo manual
      renderTabManual('by-group');
    }

    function renderManualCalendar() {
      const cycles = ['4x3', '5x2', '6x1'];
      const shifts = [
        { id: 'day', label: 'D√çA', emoji: '‚òÄÔ∏è', color: 'bg-amber-100', borderColor: 'border-amber-500' },
        { id: 'afternoon', label: 'TARDE', emoji: 'üå§Ô∏è', color: 'bg-orange-100', borderColor: 'border-orange-500' },
        { id: 'night', label: 'NOCHE', emoji: 'üåô', color: 'bg-indigo-100', borderColor: 'border-indigo-500' }
      ];

      // Contar grupos asignados por turno
      const countByShift = { day: 0, afternoon: 0, night: 0 };
      shifts.forEach(s => {
        const list = state.shiftAssignments[s.id] || [];
        countByShift[s.id] = list.length;
      });

      return `
        <div class="space-y-6">
          <!-- Grupos disponibles -->
          <div class="glass rounded-2xl p-6 border-2 border-amber-400" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);">
            <div class="flex items-center justify-between mb-4">
              <h3 class="text-xl font-bold flex items-center gap-2">
                <span class="text-2xl">üë•</span>
                <span>Grupos disponibles</span>
              </h3>
              <a href="#" onclick="event.preventDefault(); showModal('üéì Tutorial', '<div class=\\'space-y-3\\'><p>Arrastra una ficha de ciclo desde un grupo a uno de los turnos (D√≠a, Tarde o Noche).</p><p>Puedes configurar diferentes ciclos para cada grupo en cada turno.</p><button onclick=\\'this.closest(\\".modal-overlay\\").remove()\\' class=\\'mt-4 w-full bg-indigo-600 text-white px-4 py-2 rounded-xl font-bold hover:bg-indigo-700\\'>Entendido</button></div>');" class="text-blue-600 hover:text-blue-800 text-sm font-semibold underline">
                Ver tutorial
              </a>
            </div>
            <div class="grid grid-cols-4 md:grid-cols-8 gap-3">
              ${state.groups.map(g => `
                <div class="space-y-2">
                  <div class="${groupColors[g]} rounded-xl p-3 text-center font-bold text-lg shadow-md">
                    ${getGroupDisplayName(g)}
                  </div>
                  ${cycles.map(c => `
                    <div
                      draggable="true"
                      data-group="${g}"
                      data-cycle="${c}"
                      class="draggable-item border-2 ${groupBorders[g]} bg-white rounded-lg p-2 text-center font-semibold text-sm cursor-grab hover:shadow-lg transition-all"
                      title="Arrastra ${getGroupDisplayName(g)} con ciclo ${c}"
                    >
                      ‚ãÆ‚ãÆ ${c}
                    </div>
                  `).join('')}
                </div>
              `).join('')}
            </div>
          </div>

          <!-- Zonas de drop: D√çA, TARDE, NOCHE -->
          <div class="grid md:grid-cols-3 gap-4">
            ${shifts.map(shift => {
              const assignments = state.shiftAssignments[shift.id] || [];
              return `
                <div class="glass rounded-2xl p-6 border-2 ${shift.borderColor}" style="min-height: 400px;">
                  <div class="text-center mb-4">
                    <div class="text-4xl mb-2">${shift.emoji}</div>
                    <h3 class="text-2xl font-bold ${shift.color} rounded-xl py-3 mb-2">
                      ${shift.label}
                    </h3>
                    <p class="text-sm text-slate-600">(${countByShift[shift.id]}/4 grupos)</p>
                  </div>
                  <div
                    class="drop-zone min-h-[300px] ${shift.color} border-2 border-dashed ${shift.borderColor} rounded-xl p-4 transition-all"
                    data-shift="${shift.id}"
                  >
                    ${assignments.length === 0 ? `<p class="text-center text-slate-500 text-sm">Arrastra aqu√≠ para asignar</p>` : ''}
                    <div class="space-y-3">
                      ${assignments.map((a, idx) => `
                        <div class="border-2 ${groupBorders[a.groupId]} bg-white rounded-xl p-3 shadow-md">
                          <div class="flex items-center justify-between mb-2">
                            <span class="${groupColors[a.groupId]} chip px-3 py-1 rounded-lg font-bold">G${a.groupId}</span>
                            <button data-action="del-manual" data-shift="${shift.id}" data-idx="${idx}" class="text-rose-600 hover:text-rose-800 font-bold text-lg" title="Eliminar">üóëÔ∏è</button>
                          </div>
                          <div class="text-sm space-y-1">
                            <div><strong>Ciclo:</strong> ${a.cycle1 || '4x3'}</div>
                          </div>
                        </div>
                      `).join('')}
                    </div>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    // ---------- MODALS & HELPERS ----------
    function showModal(title, content, onClose) {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content">
          <div class="flex items-center justify-between mb-4">
            <h3 class="text-2xl font-bold">${title}</h3>
            <button class="text-2xl hover:text-red-600" onclick="this.closest('.modal-overlay').remove(); ${onClose ? onClose : ''}">&times;</button>
          </div>
          <div>${content}</div>
        </div>
      `;
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
          if(onClose) eval(onClose);
        }
      });
      document.body.appendChild(modal);
      return modal;
    }

    function updateBreadcrumb() {
      const breadcrumb = document.getElementById('breadcrumbRange');
      if (!breadcrumb) return;

      const base = new Date(state.selectedMonth + '-01');
      const months = [];
      const startYear = base.getFullYear();
      const startMonth = base.getMonth();
      for (let i = 0; i < 3; i++) {
        const year = startYear + Math.floor((startMonth + i) / 12);
        const month = (startMonth + i) % 12;
        const m = new Date(year, month, 1);
        months.push(m.toLocaleDateString('es-CL', {month: 'short', year: 'numeric'}));
      }
      breadcrumb.textContent = `üìÖ ${months.join(' ‚Üí ')}`;
    }

    function showHelpModal() {
      const content = `
        <div class="space-y-4">
          <div class="p-4 bg-indigo-50 rounded-xl">
            <h4 class="font-bold mb-2">‚å®Ô∏è Atajos de teclado</h4>
            <ul class="space-y-2 text-sm">
              <li><span class="kbd">Ctrl/‚åò + Z</span> ‚Äî Deshacer √∫ltimo cambio</li>
              <li><span class="kbd">Ctrl/‚åò + Shift + Z</span> ‚Äî Rehacer cambio</li>
              <li><span class="kbd">‚Üê</span> / <span class="kbd">‚Üí</span> ‚Äî Navegar entre meses (pr√≥ximamente)</li>
            </ul>
          </div>
          <div class="p-4 bg-emerald-50 rounded-xl">
            <h4 class="font-bold mb-2">üéØ Funciones principales</h4>
            <ul class="space-y-2 text-sm">
              <li><strong>Drag & Drop:</strong> Arrastra fichas de ciclo a las zonas de turnos</li>
              <li><strong>Duplicar:</strong> Usa el bot√≥n ‚éò para clonar una configuraci√≥n</li>
              <li><strong>Vista de 3 meses:</strong> Visualiza 3 meses continuos para mejor planificaci√≥n</li>
              <li><strong>Exportar:</strong> Descarga Excel con 12 meses de planificaci√≥n</li>
            </ul>
          </div>
          <div class="p-4 bg-amber-50 rounded-xl">
            <h4 class="font-bold mb-2">üí° Tips</h4>
            <ul class="space-y-2 text-sm">
              <li>Los cambios se guardan autom√°ticamente en tu navegador</li>
              <li>Usa "Guardar" para crear un respaldo manual</li>
              <li>El validador de reglas te ayuda a cumplir normativas laborales</li>
            </ul>
          </div>
        </div>
      `;
      showModal('üìñ Gu√≠a de uso', content);
    }

    function showTutorialModal() {
      const content = `
        <div class="space-y-4">
          <div class="p-4 bg-blue-50 rounded-xl border-l-4 border-blue-500">
            <h4 class="font-bold mb-2">Paso 1: Arrastra una ficha</h4>
            <p class="text-sm">Selecciona una ficha de ciclo (4x3, 5x2, o 6x1) de los grupos disponibles y arr√°strala a la zona de turno deseada (D√≠a, Tarde o Noche).</p>
          </div>
          <div class="p-4 bg-purple-50 rounded-xl border-l-4 border-purple-500">
            <h4 class="font-bold mb-2">Paso 2: Configura el ciclo</h4>
            <p class="text-sm">Una vez asignado, puedes ajustar el ciclo, agregar un ciclo alternado (Ciclo 2), configurar el desfase inicial y el n√∫mero de repeticiones.</p>
          </div>
          <div class="p-4 bg-green-50 rounded-xl border-l-4 border-green-500">
            <h4 class="font-bold mb-2">Paso 3: Visualiza y exporta</h4>
            <p class="text-sm">Usa las pesta√±as para ver diferentes vistas del calendario. Exporta a Excel para compartir o imprimir tu planificaci√≥n.</p>
          </div>
          <div class="text-center mt-4">
            <button onclick="this.closest('.modal-overlay').remove()" class="bg-indigo-600 text-white px-6 py-2 rounded-xl font-bold hover:bg-indigo-700">¬°Entendido!</button>
          </div>
        </div>
      `;
      showModal('üéì Tutorial r√°pido', content);
    }

    // ---------- EVENTS ----------
    function wireBasics(){
      const sd=document.getElementById('startDate'); const ed=document.getElementById('endDate'); const vm=document.getElementById('visibleMonth'); const px=document.getElementById('btnExportXLSX'); const pr=document.getElementById('btnPrint'); const sv=document.getElementById('btnSave'); const ld=document.getElementById('btnLoad'); const rs=document.getElementById('btnReset');

      sd.value=state.startDate; ed.value=state.endDate;

      sd.addEventListener('change', e=>{ pushHistory(); state.startDate=e.target.value; state.selectedMonth = state.startDate.slice(0,7); renderAll(); saveAuto(); updateBreadcrumb(); });
      ed.addEventListener('change', e=>{ pushHistory(); state.endDate=e.target.value; renderAll(); saveAuto(); });
      vm.addEventListener('change', e=>{ state.selectedMonth=e.target.value; renderTab(currentTab()); updateBreadcrumb(); });

      // Botones de navegaci√≥n de mes
      document.getElementById('btnPrevMonth')?.addEventListener('click', () => {
        const opts = monthsAvailable(buildEngine().calendar);
        const idx = opts.indexOf(state.selectedMonth);
        if (idx > 0) {
          state.selectedMonth = opts[idx - 1];
          renderTab(currentTab());
          updateBreadcrumb();
          document.getElementById('visibleMonth').value = state.selectedMonth;
        }
      });

      document.getElementById('btnNextMonth')?.addEventListener('click', () => {
        const opts = monthsAvailable(buildEngine().calendar);
        const idx = opts.indexOf(state.selectedMonth);
        if (idx < opts.length - 1) {
          state.selectedMonth = opts[idx + 1];
          renderTab(currentTab());
          updateBreadcrumb();
          document.getElementById('visibleMonth').value = state.selectedMonth;
        }
      });

      // Modales
      document.getElementById('btnHelp')?.addEventListener('click', showHelpModal);
      document.getElementById('btnTutorial')?.addEventListener('click', showTutorialModal);

      px.addEventListener('click', exportXLSX);

      // Print: solo zonas + calendarios grupo/turnos, ahora por 3 meses
      pr.addEventListener('click', ()=>{
        const {calendar, byGroup} = buildEngine();
        const month = state.selectedMonth;
        const printZones = document.getElementById('printZones');
        const printByGroup = document.getElementById('printByGroup');
        const printByShift = document.getElementById('printByShift');

        // Zonas: clonamos las tarjetas actuales
        const zonesWrapper = document.createElement('div'); zonesWrapper.className='grid md:grid-cols-3 gap-4';
        ['zone-day','zone-afternoon','zone-night'].forEach(id=>{ const sec=document.getElementById(id).cloneNode(true); sec.classList.remove('glass'); sec.classList.add('border','rounded-xl','p-4'); zonesWrapper.appendChild(sec); });
        printZones.innerHTML=''; printZones.appendChild(zonesWrapper);

        // Tablas por 3 meses
        const base = new Date(month + '-01');
        let htmlG = '', htmlS = '';
        const startYear = base.getFullYear();
        const startMonth = base.getMonth();
        for (let i = 0; i < 3; i++) {
          const year = startYear + Math.floor((startMonth + i) / 12);
          const monthNum = (startMonth + i) % 12;
          const m = new Date(year, monthNum, 1);
          const key = m.toISOString().slice(0,7);
          htmlG += `<h3 class="mt-6 mb-2 font-bold">${new Date(key+'-01').toLocaleDateString('es-CL',{month:'long',year:'numeric'})}</h3>` + htmlByGroup(byGroup, key);
          htmlS += `<h3 class="mt-6 mb-2 font-bold">${new Date(key+'-01').toLocaleDateString('es-CL',{month:'long',year:'numeric'})}</h3>` + htmlByShift(monthByShift(calendar, key));
        }
        printByGroup.innerHTML = htmlG;
        printByShift.innerHTML = htmlS;

        window.print();
      });

      sv.addEventListener('click', () => saveToSheets());
      ld.addEventListener('click', () => loadFromSheets());
      rs.addEventListener('click', ()=>{ if(confirm('¬øResetear al estado inicial?')){ pushHistory(); state=clone(defaultState); renderAll(); saveAuto(); toast('üßπ Sistema reseteado', 'info'); }});

      // Undo/Redo
      document.getElementById('btnUndo').addEventListener('click', undo);
      document.getElementById('btnRedo').addEventListener('click', redo);
      document.addEventListener('keydown', (e)=>{ const z=(e.ctrlKey||e.metaKey)&&!e.shiftKey&&e.key.toLowerCase()==='z'; const y=(e.ctrlKey||e.metaKey)&&e.shiftKey&&e.key.toLowerCase()==='z'; if(z){ e.preventDefault(); undo(); } if(y){ e.preventDefault(); redo(); } });

      // Theme toggle
      document.getElementById('btnDark').addEventListener('click', ()=>{ document.documentElement.classList.toggle('dark'); });

      // Mode navigation (Autom√°tico/Manual)
      document.getElementById('btnModeAuto').addEventListener('click', ()=>{
        pushHistory();
        state.manualMode = false;
        updateModeUI();
        renderAll();
        saveAuto();
        toast('ü§ñ Modo autom√°tico activado', 'info');
      });

      document.getElementById('btnModeManual').addEventListener('click', ()=>{
        pushHistory();
        state.manualMode = true;
        updateModeUI();
        renderManualInterface();
        saveAuto();
        toast('‚úèÔ∏è Modo manual activado', 'info');
      });

      // Tabs - Modo Autom√°tico
      document.querySelectorAll('.tab-btn').forEach(b=> b.addEventListener('click', ()=> renderTab(b.dataset.tab)));

      // Tabs - Modo Manual
      document.querySelectorAll('.tab-btn-manual').forEach(b=> b.addEventListener('click', ()=> renderTabManual(b.dataset.tab)));
    }

    function updateModeUI() {
      const btnAuto = document.getElementById('btnModeAuto');
      const btnManual = document.getElementById('btnModeManual');
      const sectionAuto = document.getElementById('sectionAuto');
      const sectionManual = document.getElementById('sectionManual');

      if (state.manualMode) {
        // Activar modo manual
        btnManual.className = 'mode-nav-btn px-6 py-2 rounded-lg font-semibold text-sm transition-all bg-purple-500 text-white shadow-sm';
        btnAuto.className = 'mode-nav-btn px-6 py-2 rounded-lg font-semibold text-sm transition-all bg-transparent text-slate-700 hover:bg-white/50';
        sectionAuto.style.display = 'none';
        sectionManual.style.display = 'block';
      } else {
        // Activar modo autom√°tico
        btnAuto.className = 'mode-nav-btn px-6 py-2 rounded-lg font-semibold text-sm transition-all bg-indigo-500 text-white shadow-sm';
        btnManual.className = 'mode-nav-btn px-6 py-2 rounded-lg font-semibold text-sm transition-all bg-transparent text-slate-700 hover:bg-white/50';
        sectionAuto.style.display = 'block';
        sectionManual.style.display = 'none';
      }
    }

    function wireZoneButtons(){ document.querySelectorAll('[data-action]').forEach(btn=>{ btn.addEventListener('change', onCardAction); btn.addEventListener('click', onCardAction); }); const apply=document.getElementById('btnApplyRules'); if(apply){ apply.onclick=()=>{ pushHistory(); state.rules.minFreeSundaysPerMonth=parseInt(document.getElementById('ruleSundays').value||2); state.rules.maxConsecutiveWorkDays=parseInt(document.getElementById('ruleStreak').value||6); renderTab('rules'); saveAuto(); } } }

    function onCardAction(e){
      const t=e.currentTarget;
      const act=t.dataset.action;
      if(!act) return;
      const shift=t.dataset.shift;
      const idx=parseInt(t.dataset.idx);
      pushHistory();

      // Usar asignaciones manuales o autom√°ticas seg√∫n el modo
      const assignments = state.manualMode ? state.manualAssignments : state.shiftAssignments;

      if(act==='del'){ assignments[shift].splice(idx,1); renderAll(); saveAuto(); return; }
      if(act==='dup'){ assignments[shift].splice(idx+1,0, clone(assignments[shift][idx])); renderAll(); saveAuto(); return; }
      if(act==='c1'){ assignments[shift][idx].cycle1=t.value; renderAll(); saveAuto(); return; }
      if(act==='c2'){ assignments[shift][idx].cycle2=t.value||null; renderAll(); saveAuto(); return; }
      if(act==='ofs'){ assignments[shift][idx].startOffset=parseInt(t.value||0); renderAll(); saveAuto(); return; }
      if(act==='r1'){ assignments[shift][idx].cycle1Repeat=parseInt(t.value||1); renderAll(); saveAuto(); return; }
    }

    // Drag & Drop con feedback visual - usando delegaci√≥n de eventos
    let dndWired = false; // Flag para evitar configurar listeners m√∫ltiples veces
    function wireDnD(){
      if(dndWired) return; // Ya configurado, no hacer nada
      dndWired = true;

      let dragged=null;
      let touchItem = null;

      // Usar delegaci√≥n de eventos en el document para evitar agregar listeners m√∫ltiples
      document.addEventListener('dragstart', (e)=>{
        const el = e.target.closest('[draggable="true"]');
        if(!el || !el.dataset.group) return;
        dragged={ groupId: el.dataset.group, cycle: el.dataset.cycle };
        el.classList.add('dragging');
      });

      document.addEventListener('dragend', (e)=>{
        const el = e.target.closest('[draggable="true"]');
        if(!el) return;
        el.classList.remove('dragging');
      });

      document.addEventListener('dragover', (e)=> {
        const zone = e.target.closest('[data-drop-zone]');
        if(!zone) return;
        e.preventDefault();
        zone.classList.add('drag-over');
      });

      document.addEventListener('dragleave', (e)=> {
        const zone = e.target.closest('[data-drop-zone]');
        if(!zone) return;
        // Solo remover si realmente salimos de la zona
        if(!zone.contains(e.relatedTarget)) {
          zone.classList.remove('drag-over');
        }
      });

      document.addEventListener('drop', (e)=>{
        const zone = e.target.closest('[data-drop-zone]');
        if(!zone) return;
        e.preventDefault();
        zone.classList.remove('drag-over');

        if(!dragged) return;
        const key=zone.dataset.dropZone;
        // Usar asignaciones manuales o autom√°ticas seg√∫n el modo
        const list = state.manualMode ? state.manualAssignments[key] : state.shiftAssignments[key];

        if(list.length>=state.maxGroupsPerShift) {
          toast('‚ö†Ô∏è Este turno ya alcanz√≥ el m√°ximo de grupos', 'error');
          return;
        }

        if(list.some(a=> a.groupId===dragged.groupId)) {
          toast('‚ö†Ô∏è Este grupo ya est√° asignado a este turno', 'error');
          return;
        }

        pushHistory();
        list.push({ groupId: dragged.groupId, cycle1: dragged.cycle, cycle2: null, cycle1Repeat: 1, cycle2Repeat: 1, startOffset: 0 });
        dragged=null;
        renderAll();
        saveAuto();
        toast('‚úÖ Grupo asignado exitosamente', 'success');
      });

      // Touch support para mobile
      document.addEventListener('touchstart', (e) => {
        const el = e.target.closest('[draggable="true"]');
        if(!el || !el.dataset.group) return;
        touchItem = { groupId: el.dataset.group, cycle: el.dataset.cycle, element: el };
        el.classList.add('dragging');
      });

      document.addEventListener('touchend', (e) => {
        const el = e.target.closest('[draggable="true"]');
        if(el) el.classList.remove('dragging');

        if(!touchItem) return;

        const touch = e.changedTouches[0];
        const dropZone = document.elementFromPoint(touch.clientX, touch.clientY)?.closest('[data-drop-zone]');

        if (dropZone) {
          const key = dropZone.dataset.dropZone;
          // Usar asignaciones manuales o autom√°ticas seg√∫n el modo
          const list = state.manualMode ? state.manualAssignments[key] : state.shiftAssignments[key];

          if(list.length >= state.maxGroupsPerShift) {
            toast('‚ö†Ô∏è Este turno ya alcanz√≥ el m√°ximo de grupos', 'error');
            touchItem = null;
            return;
          }

          if(list.some(a => a.groupId === touchItem.groupId)) {
            toast('‚ö†Ô∏è Este grupo ya est√° asignado a este turno', 'error');
            touchItem = null;
            return;
          }

          pushHistory();
          list.push({ groupId: touchItem.groupId, cycle1: touchItem.cycle, cycle2: null, cycle1Repeat: 1, cycle2Repeat: 1, startOffset: 0 });
          renderAll();
          saveAuto();
          toast('‚úÖ Grupo asignado exitosamente', 'success');
        }

        touchItem = null;
      });
    }

    // Undo/Redo impl
    const undo=()=>{
      if(!undoStack.length) return;
      const prev=undoStack.pop();
      redoStack.push(clone(state));
      state=prev;
      renderAll();
      // Actualizar vista del modo manual si estamos en ese modo
      if(state.manualMode) {
        const currentTabManual = document.querySelector('.tab-btn-manual.bg-white\\/60')?.dataset.tab || 'by-group';
        renderTabManual(currentTabManual);
      }
      saveAuto();
      toast('‚Ü©Ô∏è Cambio deshecho', 'info');
    };
    const redo=()=>{
      if(!redoStack.length) return;
      const next=redoStack.pop();
      undoStack.push(clone(state));
      state=next;
      renderAll();
      // Actualizar vista del modo manual si estamos en ese modo
      if(state.manualMode) {
        const currentTabManual = document.querySelector('.tab-btn-manual.bg-white\\/60')?.dataset.tab || 'by-group';
        renderTabManual(currentTabManual);
      }
      saveAuto();
      toast('‚Ü™Ô∏è Cambio rehecho', 'info');
    };

    const toast=(msg, type='success')=>{
      const el=document.createElement('div');
      el.className=`toast toast-${type}`;
      el.textContent=msg;
      document.body.appendChild(el);
      setTimeout(()=>{
        el.style.opacity='0';
        setTimeout(()=>el.remove(),300);
      },2500);
    };

    // saveAuto ya est√° definido arriba con Google Apps Script

    function showLoading(message = 'Procesando...') {
      const loader = document.createElement('div');
      loader.id = 'globalLoader';
      loader.className = 'modal-overlay';
      loader.innerHTML = `
        <div class="bg-white rounded-2xl p-8 text-center">
          <div class="spinner mx-auto mb-4"></div>
          <div class="text-lg font-semibold">${message}</div>
        </div>
      `;
      document.body.appendChild(loader);
      return loader;
    }

    function hideLoading() {
      const loader = document.getElementById('globalLoader');
      if (loader) loader.remove();
    }

    /**
     * Aplicar color a una celda de Excel (compatible con xlsx-js-style)
     */
    function applyCellColor(ws, cellAddress, bgColorHex, textColor = 'FFFFFF') {
      if (!ws[cellAddress]) return;

      ws[cellAddress].s = {
        fill: {
          patternType: 'solid',
          fgColor: { rgb: bgColorHex }
        },
        font: {
          color: { rgb: textColor },
          bold: true,
          sz: 11
        },
        alignment: {
          horizontal: 'center',
          vertical: 'center'
        },
        border: {
          top: { style: 'thin', color: { rgb: 'CCCCCC' } },
          bottom: { style: 'thin', color: { rgb: 'CCCCCC' } },
          left: { style: 'thin', color: { rgb: 'CCCCCC' } },
          right: { style: 'thin', color: { rgb: 'CCCCCC' } }
        }
      };
    }

    /**
     * Aplicar estilo a header (compatible con xlsx-js-style)
     */
    function applyHeaderStyle(ws, cellAddress) {
      if (!ws[cellAddress]) return;

      ws[cellAddress].s = {
        fill: {
          patternType: 'solid',
          fgColor: { rgb: '1F2937' } // gray-800
        },
        font: {
          color: { rgb: 'FFFFFF' },
          bold: true,
          sz: 12
        },
        alignment: {
          horizontal: 'center',
          vertical: 'center'
        },
        border: {
          top: { style: 'medium', color: { rgb: '000000' } },
          bottom: { style: 'medium', color: { rgb: '000000' } },
          left: { style: 'medium', color: { rgb: '000000' } },
          right: { style: 'medium', color: { rgb: '000000' } }
        }
      };
    }

    /**
     * Obtener color del grupo en formato HEX
     */
    function getGroupColorHex(groupId) {
      return groupColorsHex[groupId] || '6B7280'; // gray-500 por defecto
    }

    function exportXLSX(){
      const modeLabel = state.manualMode ? 'Manual' : 'Autom√°tico';
      const loader = showLoading(`üìä Generando Excel (${modeLabel})...`);

      setTimeout(() => {
        try {
          const {calendar, byGroup} = state.manualMode ? buildManualCalendar() : buildEngine();
          const wb = XLSX.utils.book_new();
          const today = new Date().toISOString().slice(0,10);

          if(state.manualMode) {
            // ========== MODO MANUAL ==========
            exportManualMode(wb, byGroup, calendar);
          } else {
            // ========== MODO AUTOM√ÅTICO ==========
            exportAutoMode(wb, byGroup, calendar);
          }

          const fileName = `Turnos_${state.manualMode ? 'Manual' : 'Automatico'}_${today}.xlsx`;
          XLSX.writeFile(wb, fileName);
          hideLoading();
          toast(`‚úÖ Excel ${state.manualMode ? 'manual' : 'autom√°tico'} exportado exitosamente`, 'success');
        } catch (error) {
          hideLoading();
          toast('‚ùå Error al generar Excel: ' + error.message, 'error');
          console.error(error);
        }
      }, 100);
    }

    // Exportar modo manual
    function exportManualMode(wb, byGroup, calendar) {
      const allGroups = Object.keys(byGroup).sort();

      // Parsear fechas correctamente
      const [startY, startM, startD] = state.startDate.split('-').map(Number);
      const [endY, endM, endD] = state.endDate.split('-').map(Number);
      const start = new Date(startY, startM - 1, startD);
      const end = new Date(endY, endM - 1, endD);

      // HOJA 1: Vista por Grupos
      const groupHeader = ['Fecha', 'D√≠a Semana', ...allGroups.map(g => getGroupDisplayName(g))];
      const groupRows = [groupHeader];

      const currentDate1 = new Date(start);
      while(currentDate1 <= end) {
        const y = currentDate1.getFullYear();
        const m = String(currentDate1.getMonth() + 1).padStart(2, '0');
        const d = String(currentDate1.getDate()).padStart(2, '0');
        const dateStr = `${y}-${m}-${d}`;

        const row = [
          currentDate1.toLocaleDateString('es-CL'),
          currentDate1.toLocaleDateString('es-CL', {weekday:'long'})
        ];

        allGroups.forEach(g => {
          const groupDays = state.manualDaysByGroup[g] || {};
          const shift = groupDays[dateStr] || 'rest';
          row.push(
            shift === 'day' ? 'D√≠a' :
            shift === 'afternoon' ? 'Tarde' :
            shift === 'night' ? 'Noche' : 'Descanso'
          );
        });

        groupRows.push(row);
        currentDate1.setDate(currentDate1.getDate() + 1);
      }

      const wsGroups = XLSX.utils.aoa_to_sheet(groupRows);
      wsGroups['!cols'] = [
        { wch: 12 },
        { wch: 12 },
        ...allGroups.map(() => ({ wch: 12 }))
      ];

      // Aplicar estilos a headers
      applyHeaderStyle(wsGroups, 'A1');
      applyHeaderStyle(wsGroups, 'B1');
      allGroups.forEach((g, idx) => {
        const col = String.fromCharCode(67 + idx); // C, D, E, ...
        applyHeaderStyle(wsGroups, col + '1');
      });

      // Aplicar colores a las celdas de grupos
      const currentDate = new Date(start);
      let rowIdx = 2; // Empezar en fila 2 (despu√©s del header)
      while(currentDate <= end) {
        const y = currentDate.getFullYear();
        const m = String(currentDate.getMonth() + 1).padStart(2, '0');
        const d = String(currentDate.getDate()).padStart(2, '0');
        const dateStr = `${y}-${m}-${d}`;

        allGroups.forEach((g, colIdx) => {
          const col = String.fromCharCode(67 + colIdx); // C, D, E, ...
          const cellAddress = col + rowIdx;
          const groupDays = state.manualDaysByGroup[g] || {};
          const shift = groupDays[dateStr] || 'rest';

          // Solo aplicar color si NO es descanso
          if (shift !== 'rest') {
            applyCellColor(wsGroups, cellAddress, getGroupColorHex(g));
          }
        });

        currentDate.setDate(currentDate.getDate() + 1);
        rowIdx++;
      }

      XLSX.utils.book_append_sheet(wb, wsGroups, 'Vista por Grupos');

      // HOJA 2: Vista por Turnos
      const shiftHeader = ['Fecha', 'D√≠a Semana', 'D√çA', 'TARDE', 'NOCHE'];
      const shiftRows = [shiftHeader];

      const currentDate2 = new Date(start);
      while(currentDate2 <= end) {
        const y = currentDate2.getFullYear();
        const m = String(currentDate2.getMonth() + 1).padStart(2, '0');
        const d = String(currentDate2.getDate()).padStart(2, '0');
        const dateStr = `${y}-${m}-${d}`;

        const groupsInDay = { day: [], afternoon: [], night: [] };

        allGroups.forEach(g => {
          const groupDays = state.manualDaysByGroup[g] || {};
          const shift = groupDays[dateStr];
          if(shift && shift !== 'rest') {
            groupsInDay[shift].push(getGroupDisplayName(g));
          }
        });

        const row = [
          currentDate2.toLocaleDateString('es-CL'),
          currentDate2.toLocaleDateString('es-CL', {weekday:'long'}),
          groupsInDay.day.join(', ') || '-',
          groupsInDay.afternoon.join(', ') || '-',
          groupsInDay.night.join(', ') || '-'
        ];

        shiftRows.push(row);
        currentDate2.setDate(currentDate2.getDate() + 1);
      }

      const wsShifts = XLSX.utils.aoa_to_sheet(shiftRows);
      wsShifts['!cols'] = [
        { wch: 12 },
        { wch: 12 },
        { wch: 35 },
        { wch: 35 },
        { wch: 35 }
      ];

      // Aplicar estilos a headers
      applyHeaderStyle(wsShifts, 'A1');
      applyHeaderStyle(wsShifts, 'B1');
      // Headers de turnos con colores espec√≠ficos
      applyCellColor(wsShifts, 'C1', 'FEF3C7', '92400E'); // D√≠a: amarillo
      applyCellColor(wsShifts, 'D1', 'FED7AA', '9A3412'); // Tarde: naranja
      applyCellColor(wsShifts, 'E1', 'C7D2FE', '3730A3'); // Noche: azul

      XLSX.utils.book_append_sheet(wb, wsShifts, 'Vista por Turnos');
    }

    // Exportar modo autom√°tico
    function exportAutoMode(wb, byGroup, calendar) {
      const allGroups = Object.keys(byGroup).sort();

      // Parsear fechas correctamente
      const [startY, startM, startD] = state.startDate.split('-').map(Number);
      const [endY, endM, endD] = state.endDate.split('-').map(Number);
      const start = new Date(startY, startM - 1, startD);
      const end = new Date(endY, endM - 1, endD);

      // HOJA 1: Configuraci√≥n
      const conf = [
        ['CONFIGURACI√ìN DEL SISTEMA DE TURNOS'],
        [],
        ['Modo:', 'Autom√°tico'],
        ['Fecha Inicio:', state.startDate],
        ['Fecha Fin:', state.endDate],
        [],
        ['ASIGNACIONES POR TURNO']
      ];

      ['day','afternoon','night'].forEach(k => {
        const shiftNames = {day:'D√çA', afternoon:'TARDE', night:'NOCHE'};
        conf.push([`Turno ${shiftNames[k]}:`]);
        state.shiftAssignments[k].forEach(a => conf.push([
          `  ${getGroupDisplayName(a.groupId)}`,
          `Ciclo 1: ${a.cycle1}`,
          a.cycle2 ? `Ciclo 2: ${a.cycle2}` : 'Sin ciclo 2',
          `Desfase: ${a.startOffset}`
        ]));
        conf.push([]);
      });

      const wsConf = XLSX.utils.aoa_to_sheet(conf);
      XLSX.utils.book_append_sheet(wb, wsConf, '1. Configuraci√≥n');

      // HOJA 2: Vista por Turnos (lineal)
      const shiftHeader = ['Fecha', 'D√≠a Semana', 'D√çA', 'TARDE', 'NOCHE'];
      const shiftRows = [shiftHeader];

      const currentDate1 = new Date(start);
      while(currentDate1 <= end) {
        const groupsInDay = { day: [], afternoon: [], night: [] };

        // Calcular qu√© grupos trabajan en cada turno ese d√≠a
        calendar.day.forEach(dayEntry => {
          if(dayEntry.date === currentDate1.toISOString().slice(0, 10)) {
            dayEntry.groups.forEach(g => {
              if(g.isWorking) groupsInDay.day.push(getGroupDisplayName(g.groupId));
            });
          }
        });

        calendar.afternoon.forEach(dayEntry => {
          if(dayEntry.date === currentDate1.toISOString().slice(0, 10)) {
            dayEntry.groups.forEach(g => {
              if(g.isWorking) groupsInDay.afternoon.push(getGroupDisplayName(g.groupId));
            });
          }
        });

        calendar.night.forEach(dayEntry => {
          if(dayEntry.date === currentDate1.toISOString().slice(0, 10)) {
            dayEntry.groups.forEach(g => {
              if(g.isWorking) groupsInDay.night.push(getGroupDisplayName(g.groupId));
            });
          }
        });

        const row = [
          currentDate1.toLocaleDateString('es-CL'),
          currentDate1.toLocaleDateString('es-CL', {weekday:'long'}),
          groupsInDay.day.join(', ') || '-',
          groupsInDay.afternoon.join(', ') || '-',
          groupsInDay.night.join(', ') || '-'
        ];

        shiftRows.push(row);
        currentDate1.setDate(currentDate1.getDate() + 1);
      }

      const wsShifts = XLSX.utils.aoa_to_sheet(shiftRows);
      wsShifts['!cols'] = [
        { wch: 12 },
        { wch: 12 },
        { wch: 35 },
        { wch: 35 },
        { wch: 35 }
      ];

      // Aplicar estilos a headers
      applyHeaderStyle(wsShifts, 'A1');
      applyHeaderStyle(wsShifts, 'B1');
      // Headers de turnos con colores espec√≠ficos
      applyCellColor(wsShifts, 'C1', 'FEF3C7', '92400E'); // D√≠a: amarillo
      applyCellColor(wsShifts, 'D1', 'FED7AA', '9A3412'); // Tarde: naranja
      applyCellColor(wsShifts, 'E1', 'C7D2FE', '3730A3'); // Noche: azul

      XLSX.utils.book_append_sheet(wb, wsShifts, '2. Vista por Turnos');

      // HOJA 3: Vista por Grupos (lineal)
      const groupHeader = ['Fecha', 'D√≠a Semana', ...allGroups.map(g => getGroupDisplayName(g))];
      const groupRows = [groupHeader];

      const currentDate2 = new Date(start);
      while(currentDate2 <= end) {
        const y = currentDate2.getFullYear();
        const m = String(currentDate2.getMonth() + 1).padStart(2, '0');
        const d = String(currentDate2.getDate()).padStart(2, '0');
        const dateStr = `${y}-${m}-${d}`;

        const row = [
          currentDate2.toLocaleDateString('es-CL'),
          currentDate2.toLocaleDateString('es-CL', {weekday:'long'})
        ];

        allGroups.forEach(g => {
          const groupData = byGroup[g];
          const dayData = groupData.find(day => day.date === dateStr);

          if(dayData) {
            row.push(
              dayData.shift === 'day' ? 'D√≠a' :
              dayData.shift === 'afternoon' ? 'Tarde' :
              dayData.shift === 'night' ? 'Noche' : 'Descanso'
            );
          } else {
            row.push('Descanso');
          }
        });

        groupRows.push(row);
        currentDate2.setDate(currentDate2.getDate() + 1);
      }

      const wsGroups = XLSX.utils.aoa_to_sheet(groupRows);
      wsGroups['!cols'] = [
        { wch: 12 },
        { wch: 12 },
        ...allGroups.map(() => ({ wch: 12 }))
      ];

      // Aplicar estilos a headers
      applyHeaderStyle(wsGroups, 'A1');
      applyHeaderStyle(wsGroups, 'B1');
      allGroups.forEach((g, idx) => {
        const col = String.fromCharCode(67 + idx); // C, D, E, ...
        applyHeaderStyle(wsGroups, col + '1');
      });

      // Aplicar colores a las celdas de grupos
      const currentDate3 = new Date(start);
      let rowIdx = 2; // Empezar en fila 2 (despu√©s del header)
      while(currentDate3 <= end) {
        const y = currentDate3.getFullYear();
        const m = String(currentDate3.getMonth() + 1).padStart(2, '0');
        const d = String(currentDate3.getDate()).padStart(2, '0');
        const dateStr = `${y}-${m}-${d}`;

        allGroups.forEach((g, colIdx) => {
          const col = String.fromCharCode(67 + colIdx); // C, D, E, ...
          const cellAddress = col + rowIdx;
          const groupData = byGroup[g];
          const dayData = groupData.find(day => day.date === dateStr);

          // Solo aplicar color si NO es descanso
          if (dayData && dayData.shift !== 'rest' && dayData.isWorking) {
            applyCellColor(wsGroups, cellAddress, getGroupColorHex(g));
          }
        });

        currentDate3.setDate(currentDate3.getDate() + 1);
        rowIdx++;
      }

      XLSX.utils.book_append_sheet(wb, wsGroups, '3. Vista por Grupos');
    }

    // ---------- MANUAL CALENDAR DRAG & DROP ----------
    let manualDndWired = false; // Flag para evitar configurar listeners m√∫ltiples veces
    function wireManualDnD() {
      if(manualDndWired) return; // Ya configurado, no hacer nada
      manualDndWired = true;

      let draggedItem = null;

      // Usar delegaci√≥n de eventos para elementos arrastrables
      document.addEventListener('dragstart', (e) => {
        const chip = e.target.closest('.draggable-item');
        if(!chip) return;
        draggedItem = {
          groupId: chip.dataset.group,
          cycle: chip.dataset.cycle
        };
        chip.classList.add('dragging');
      });

      document.addEventListener('dragend', (e) => {
        const chip = e.target.closest('.draggable-item');
        if(!chip) return;
        chip.classList.remove('dragging');
      });

      // Zonas de drop autom√°ticas (D√çA, TARDE, NOCHE) - Para el tab manual del modo autom√°tico
      document.addEventListener('dragover', (e) => {
        const zone = e.target.closest('.drop-zone');
        if(!zone) return;
        e.preventDefault();
        zone.classList.add('drag-over');
      });

      document.addEventListener('dragleave', (e) => {
        const zone = e.target.closest('.drop-zone');
        if(!zone) return;
        if(!zone.contains(e.relatedTarget)) {
          zone.classList.remove('drag-over');
        }
      });

      document.addEventListener('drop', (e) => {
        const zone = e.target.closest('.drop-zone');
        if(!zone) return;
        e.preventDefault();
        zone.classList.remove('drag-over');

        if (draggedItem) {
          const shift = zone.dataset.shift;
          const { groupId, cycle } = draggedItem;

          // Verificar si el grupo ya est√° asignado a este turno
          const list = state.shiftAssignments[shift] || [];
          if (list.some(a => a.groupId === groupId)) {
            toast(`‚ö†Ô∏è El grupo G${groupId} ya est√° asignado a ${shift === 'day' ? 'D√çA' : shift === 'afternoon' ? 'TARDE' : 'NOCHE'}`, 'error');
            draggedItem = null;
            return;
          }

          // Verificar l√≠mite de grupos por turno
          if (list.length >= state.maxGroupsPerShift) {
            toast(`‚ö†Ô∏è Ya hay ${state.maxGroupsPerShift} grupos asignados a este turno`, 'error');
            draggedItem = null;
            return;
          }

          // Agregar asignaci√≥n
          pushHistory();
          if (!state.shiftAssignments[shift]) {
            state.shiftAssignments[shift] = [];
          }
          state.shiftAssignments[shift].push({
            groupId: groupId,
            cycle1: cycle,
            cycle2: null,
            cycle1Repeat: 1,
            cycle2Repeat: 1,
            startOffset: 0
          });

          renderTab('manual');
          renderAll();
          saveAuto();
          toast(`‚úÖ G${groupId} (${cycle}) asignado a ${shift === 'day' ? 'D√çA' : shift === 'afternoon' ? 'TARDE' : 'NOCHE'}`, 'success');
          draggedItem = null;
        }
      });

      // Zonas de drop manuales (D√çA, TARDE, NOCHE) - Para la secci√≥n del modo manual
      // Usar eventos separados para .drop-zone-manual usando closest espec√≠fico
      document.addEventListener('dragover', (e) => {
        const zone = e.target.closest('.drop-zone-manual');
        if(!zone) return;
        e.preventDefault();
        zone.classList.add('drag-over');
      });

      document.addEventListener('dragleave', (e) => {
        const zone = e.target.closest('.drop-zone-manual');
        if(!zone) return;
        if(!zone.contains(e.relatedTarget)) {
          zone.classList.remove('drag-over');
        }
      });

      document.addEventListener('drop', (e) => {
        const zone = e.target.closest('.drop-zone-manual');
        if(!zone) return;
        e.preventDefault();
        zone.classList.remove('drag-over');

        if (draggedItem) {
          const shift = zone.dataset.shift;
          const { groupId, cycle } = draggedItem;

          // Verificar si el grupo ya est√° asignado a este turno
          const list = state.manualAssignments[shift] || [];
          if (list.some(a => a.groupId === groupId)) {
            toast(`‚ö†Ô∏è El grupo G${groupId} ya est√° asignado a ${shift === 'day' ? 'D√çA' : shift === 'afternoon' ? 'TARDE' : 'NOCHE'}`, 'error');
            draggedItem = null;
            return;
          }

          // Verificar l√≠mite de grupos por turno
          if (list.length >= state.maxGroupsPerShift) {
            toast(`‚ö†Ô∏è Ya hay ${state.maxGroupsPerShift} grupos asignados a este turno`, 'error');
            draggedItem = null;
            return;
          }

          // Agregar asignaci√≥n
          pushHistory();
          if (!state.manualAssignments[shift]) {
            state.manualAssignments[shift] = [];
          }
          state.manualAssignments[shift].push({
            groupId: groupId,
            cycle1: cycle,
            cycle2: null,
            cycle1Repeat: 1,
            cycle2Repeat: 1,
            startOffset: 0
          });

          renderManualInterface();
          saveAuto();
          toast(`‚úÖ G${groupId} (${cycle}) asignado a ${shift === 'day' ? 'D√çA' : shift === 'afternoon' ? 'TARDE' : 'NOCHE'}`, 'success');
          draggedItem = null;
        }
      });

      // Botones de eliminar usando delegaci√≥n
      document.addEventListener('click', (e) => {
        const btn = e.target.closest('[data-action="del-manual"]');
        if(!btn) return;

        const shift = btn.dataset.shift;
        const idx = parseInt(btn.dataset.idx);

        // Determinar si estamos en modo manual o autom√°tico
        const isManualSection = document.getElementById('sectionManual').style.display !== 'none';
        const assignments = isManualSection ? state.manualAssignments : state.shiftAssignments;
        const assignment = assignments[shift][idx];

        if (confirm(`¬øEliminar G${assignment.groupId} de ${shift === 'day' ? 'D√çA' : shift === 'afternoon' ? 'TARDE' : 'NOCHE'}?`)) {
          pushHistory();
          assignments[shift].splice(idx, 1);

          if (isManualSection) {
            renderManualInterface();
          } else {
            renderTab('manual');
            renderAll();
          }

          saveAuto();
          toast('üóëÔ∏è Grupo eliminado', 'info');
        }
      });
    }

    function assignManualShift(date, shiftId) {
      // Asegurar que manualCalendar exista
      if (!state.manualCalendar) {
        state.manualCalendar = {};
      }

      if (!state.manualCalendar[date]) {
        state.manualCalendar[date] = { shifts: [] };
      }

      // Validaci√≥n: no repetir el mismo turno en un d√≠a
      if (state.manualCalendar[date].shifts.includes(shiftId)) {
        toast(`‚ö†Ô∏è Ya existe un turno de ${getShiftLabel(shiftId)} en este d√≠a`, 'error');
        return;
      }

      pushHistory();
      state.manualCalendar[date].shifts.push(shiftId);
      saveAuto();
      renderTab('manual');
      toast(`‚úÖ Turno de ${getShiftLabel(shiftId)} asignado`, 'success');
    }

    function removeManualShift(date, shiftId) {
      // Asegurar que manualCalendar exista
      if (!state.manualCalendar) {
        state.manualCalendar = {};
      }

      if (!state.manualCalendar[date]) return;

      pushHistory();
      state.manualCalendar[date].shifts = state.manualCalendar[date].shifts.filter(s => s !== shiftId);

      // Limpiar el d√≠a si no tiene turnos
      if (state.manualCalendar[date].shifts.length === 0) {
        delete state.manualCalendar[date];
      }

      saveAuto();
      renderTab('manual');
      toast(`üóëÔ∏è Turno de ${getShiftLabel(shiftId)} eliminado`, 'info');
    }

    function clearManualMonth() {
      // Asegurar que manualCalendar exista
      if (!state.manualCalendar) {
        state.manualCalendar = {};
      }

      const month = state.selectedMonth;
      pushHistory();

      // Eliminar solo los d√≠as del mes actual
      Object.keys(state.manualCalendar).forEach(date => {
        if (date.startsWith(month)) {
          delete state.manualCalendar[date];
        }
      });

      saveAuto();
      renderTab('manual');
      toast('üßπ Mes limpiado completamente', 'info');
    }

    function getShiftLabel(shiftId) {
      const labels = { day: 'D√≠a', afternoon: 'Tarde', night: 'Noche', rest: 'Descanso' };
      return labels[shiftId] || shiftId;
    }

    function exportManualCalendar() {
      // Asegurar que manualCalendar exista
      if (!state.manualCalendar) {
        state.manualCalendar = {};
      }

      const loader = showLoading('üìä Generando Excel del calendario manual...');

      setTimeout(() => {
        try {
          const wb = XLSX.utils.book_new();
          const today = new Date().toISOString().slice(0, 10);

          // Hoja del calendario manual
          const month = state.selectedMonth;
          const days = daysInMonth(month);

          const rows = [
            ['Fecha', 'D√≠a Semana', 'Turnos Asignados'],
            []
          ];

          days.forEach(day => {
            const dateStr = day.date;
            const dayData = state.manualCalendar[dateStr];
            const weekday = day.js.toLocaleDateString('es-CL', { weekday: 'long' });
            const shifts = dayData && dayData.shifts.length > 0
              ? dayData.shifts.map(s => getShiftLabel(s)).join(', ')
              : '-';

            rows.push([
              day.js.toLocaleDateString('es-CL'),
              weekday,
              shifts
            ]);
          });

          const ws = XLSX.utils.aoa_to_sheet(rows);
          ws['!cols'] = [{ wch: 12 }, { wch: 15 }, { wch: 30 }];

          XLSX.utils.book_append_sheet(wb, ws, 'Calendario Manual');

          XLSX.writeFile(wb, `Calendario_Manual_${month}_${today}.xlsx`);
          hideLoading();
          toast('‚úÖ Calendario manual exportado exitosamente', 'success');
        } catch (error) {
          hideLoading();
          toast('‚ùå Error al exportar: ' + error.message, 'error');
          console.error(error);
        }
      }, 100);
    }

    // ---------- INIT ----------
    (async function init(){
      let isFirstLoad = true;

      // Intentar cargar estado guardado desde Google Sheets
      if (typeof google !== 'undefined' && google.script && google.script.run) {
        try {
          const response = await new Promise((resolve, reject) => {
            google.script.run
              .withSuccessHandler(resolve)
              .withFailureHandler(reject)
              .loadState();
          });

          if (response.success && response.data) {
            try {
              state = JSON.parse(response.data);
              isFirstLoad = false;
              console.log('‚úÖ Estado cargado desde Google Sheets');
            } catch (error) {
              console.error('‚ùå Error al parsear estado guardado:', error);
            }
          }
        } catch (error) {
          console.log('‚ÑπÔ∏è No hay estado previo guardado, usando defaultState');
        }
      } else {
        console.warn('‚ö†Ô∏è Google Apps Script no disponible - usando modo local');
      }

      // Forzar fechas correctas desde defaultState para coherencia
      state.startDate = defaultState.startDate;
      state.endDate = defaultState.endDate;

      // Determinar mes inicial de manera inteligente
      const currentMonth = new Date().toISOString().slice(0,7);
      const startMonth = state.startDate.slice(0,7);
      const endMonth = state.endDate.slice(0,7);

      if(isFirstLoad) {
        // Primera carga: usar mes actual si est√° en el rango, sino usar startDate
        if(currentMonth >= startMonth && currentMonth <= endMonth) {
          state.selectedMonth = currentMonth;
        } else {
          state.selectedMonth = startMonth;
        }
      } else {
        // Carga posterior: validar que el mes guardado est√© en rango v√°lido
        const savedMonth = state.selectedMonth;
        if(!savedMonth || savedMonth < startMonth || savedMonth > endMonth) {
          // Si el mes guardado est√° fuera de rango o no existe, usar startDate
          state.selectedMonth = startMonth;
        }
        // Si el mes guardado es v√°lido, lo mantenemos (no hacemos nada)
      }
      // Asegurar que propiedades nuevas existan (para compatibilidad con estados antiguos)
      if(!state.manualCalendar){ state.manualCalendar = {}; }
      if(state.manualMode === undefined){ state.manualMode = false; }
      if(!state.manualAssignments){ state.manualAssignments = { day: [], afternoon: [], night: [] }; }
      if(!state.manualDays){ state.manualDays = {}; }
      if(!state.manualDaysByGroup){ state.manualDaysByGroup = {}; }
      if(state.selectedShiftType === undefined){ state.selectedShiftType = null; }
      if(state.selectedGroupId === undefined){ state.selectedGroupId = null; }
      if(!state.groupNames){
        state.groupNames = {};
        state.groups.forEach((g, idx) => {
          state.groupNames[g] = `Grupo ${idx + 1}`;
        });
      }

      wireBasics();
      wireDnD(); // Configurar drag & drop una sola vez
      wireManualDnD(); // Configurar drag & drop manual una sola vez
      updateModeUI(); // Actualizar UI del modo
      renderAll();
      renderTab('by-group'); // Mostrar pesta√±a por defecto
      updateBreadcrumb();

      // Anunciar p√°gina cargada para lectores de pantalla
      setTimeout(() => {
        const announcement = document.createElement('div');
        announcement.setAttribute('role', 'status');
        announcement.setAttribute('aria-live', 'polite');
        announcement.className = 'sr-only';
        announcement.textContent = 'Simulador de turnos cargado correctamente. Use Tab para navegar entre controles.';
        document.body.appendChild(announcement);
        setTimeout(() => announcement.remove(), 3000);
      }, 1000);
    })();
  </script>
</body>
</html>
